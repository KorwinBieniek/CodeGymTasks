taskKey="com.codegym.task.task33.task3310.\n\nShortener (9)


Let&#39;s write another strategy. We&#39;ll call it FileStorageStrategy. It will be very similar
to OurHashMapStorageStrategy, but files will be
the buckets. I&#39;m sure you know what I mean by buckets. If not, copy the internal workings
of HashMap.
9.1.	Create a FileBucket class in the strategy package.
9.2.	Add a Path path field to the class. This will be the path to the file.
9.3.	Add a no-argument constructor to the class. It should:
9.3.1.	Initialize the path field with a temporary file. The file must be placed
in the directory for temporary files and have a random name. Hint:
Files.createTempFile.
9.3.2.	Use the path field to create a new file. If the file already exists, then
replace it.
9.3.3.	Ensure the file is deleted when you exit the program. Hint:
deleteOnExit().
9.4.	Add the following methods to the class:
9.4.1. long getFileSize() - Returns the size of the file pointed to
by path.
9.4.2. void putEntry(Entry entry) - Serializes the passed entry to
the file. Be aware that each entry may contain another entry.
9.4.3.	Entry getEntry() - Gets an entry from the file. If the file size is zero,
return null.
9.4.4. void remove() - Delete the file pointed to by path.
The constructor and methods should not throw exceptions.


Требования:
1.	A Path path field must be created in the FileBucket class.
2.	The FileBucket class&#39;s no-argument constructor must be implemented in accordance with the task conditions.
3.	The getFileSize method must return the size of the file pointed to by path.
4.	The putEntry method must serialize the passed Entry object to the file pointed to by path. To get an OutputStream, use the Files.newOutputStream method.
5.	The getEntry method must deserialize an Entry object from the file pointed to by path. To get an InputStream, use the Files.newInputStream method.
6.	The remove method should delete the file pointed to by path using the Files.delete() method.


Shortener (9)


Add and implement a OurHashMapStorageStrategy class, using the Entry class from the
previous subtask. The OurHashMapStorageStrategy class must implement
the StorageStrategy interface.
8.1. Add the following fields to the class:
8.1.1. static final int DEFAULT_INITIAL_CAPACITY = 16;
8.1.2. static final float DEFAULT_LOAD_FACTOR = 0.75f;
8.1.3. Entry[] table = new Entry[DEFAULT_INITIAL_CAPACITY];
8.1.4. int size;
8.1.5. int threshold = (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
8.1.6. float loadFactor = DEFAULT_LOAD_FACTOR;
8.2. Implement the following helper methods in the class:
8.2.1. int hash(Long k)
8.2.2. int indexFor(int hash, int length)
8.2.3. Entry getEntry(Long key)
8.2.4. void resize(int newCapacity)
8.2.5. void transfer(Entry[] newTable)
8.2.6. void addEntry(int hash, Long key, String value, int bucketIndex)
8.2.7. void createEntry(int hash, Long key, String value, int bucketIndex)
8.3. Add the public methods required by the StorageStrategy interface.
Don&#39;t use any additional fields. Don&#39;t implement any methods
not specified in the task. If you have questions on how to implement a
method or what it&#39;s supposed to do, you can always take a look at how the corresponding
method works in HashMap.
You can add testing of the new strategy to the Solution class&#39;s main method. Run the program
and compare the execution time of the two strategies on the same number of elements.



Shortener (9)


Let&#39;s start implementing the second strategy: OurHashMapStorageStrategy. It won&#39;t
use the ready-made HashMap from the standard library, but rather will itself be
a collection.

7.1.	Understand how the standard HashMap works. Look at its source code or
google for articles about it.
7.2.	If you really did the previous item, then you know what the
Node class, which supports the Entry interface, is used for inside HashMap. Create your own analog inside the
strategy package. This should be an ordinary, non-nested, non-generic class. Make it public.
Unlike the Node class in HashMap, our class will only support
the Serializable interface and will be called Entry.
7.3.	Add the following fields to Entry: Long key, String value, Entry next, int hash. As you can
see, our implementation will only support Long keys and
String values. Keep the default field visibility.
7.4.	Add and implement an Entry(int hash, Long key, String value, Entry next) constructor.
7.5.	Add and implement the following methods: Long getKey(), String getValue(), int hashCode(), boolean equals(), and String
toString(). Don&#39;t implement the remaining methods from the original Entry. We&#39;re
writing the simplified version.



Shortener (9)


The first strategy is ready. It&#39;s time to test it. To do this:
6.1.	Create a Solution class if you haven&#39;t already done so.
6.2.	Add implementations of the static helper methods to the Solution class:
6.2.1.	Set&lt;Long&gt; getIds(Shortener shortener, Set&lt;String&gt; strings). This method should
return a set of identifiers for a passed set of strings. You need to use shortner to get
the identifier for each individual string.
6.2.2.	Set&lt;String&gt; getStrings(Shortener shortener, Set&lt;Long&gt; keys). The method will
return the set of strings that matches the passed set of identifiers.
Of course, when you use Shortener for its actual purposes, you probably won&#39;t have to get a set of identifiers from a set of strings, nor vice versa.
This task is only necessary for testing.
6.2.3.	testStrategy(StorageStrategy strategy, long elementsNumber). The method will
test the passed strategy on a specific number of
elements (elementsNumber). The implementation should:
6.2.3.1.	Display the name of the class strategy. The name must not include the package name.
6.2.3.2.	Generate a test set using Helper and the specified
number of elements (elementsNumber).
6.2.3.3.	Create a Shortener object using the passed strategy.
6.2.3.4.	Measure and display the time required to run the getIds method
for the given strategy and the given set of elements. Display
time in milliseconds. When measuring the method&#39;s execution time, you can
ignore the processor switching to other threads, as well as the time
spent on the call itself, returning values, and calling methods
to get the time (date). Measure time
using Date objects.
6.2.3.5.	Measure and display the time required to run the
getStrings method for a given strategy and the set of identifiers obtained in the
previous clause.
6.2.3.6.	Check whether the contents of the set of generated strings and the set
returned by getStrings method
are the same. If the sets are the same, then display &quot;The test passed.&quot;.
Otherwise, display &quot;The test failed.&quot;.
6.2.4.	Add a main() method. Inside the method, test the
HashMapStorageStrategy strategy on 10,000 items.
6.3.	Verify that the program works and the test is passed.



Shortener (9)


Let&#39;s write our first repository (storage strategy). Internally, it will
have an ordinary HashMap. We&#39;ll keep all the strategies in the strategy package.
5.1. Create a HashMapStorageStrategy class that implements the StorageStrategy interface.
5.2. Add a HashMap&lt;Long, String&gt; data field to the class. It will store our data.
5.3. Implement all the methods the class needs. The methods&#39; implementations must
use the data field. Don&#39;t create additional fields.



Shortener (9)


We&#39;ll need several helper classes:
4.1.	Create a Helper class.
4.1.1.	Add a static String generateRandomString() method, which
will generate a random string. Use the SecureRandom
and BigInteger classes to do this. Hint: search for &quot;random string Java&quot; on Google.
The string may consist of numbers and any of the 26 letters of the lowercase English alphabet.
4.1.2.	Add a static printMessage(String message) method to the class. It should display
the passed text on the console. All subsequent output in the program should
come through this method!
4.2.	Create an ExceptionHandler class.
4.2.1.	Add a static log(Exception e) method, which will display
a brief description of the exception.



