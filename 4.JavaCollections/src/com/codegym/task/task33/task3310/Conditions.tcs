taskKey="com.codegym.task.task33.task3310.\n\nShortener (12)


It&#39;s not all that uncommon to need to create a Map that works in two directions (from key to
value, and from value to key). Implementations of such collections
already exist in various third-party libraries. One such is guava from
Google.
12.1.	Download and connect the guava library, version 19.0.
12.2.	Implement the HashBiMapStorageStrategy. It must:
12.2.1.	support the StorageStrategy interface.
12.2.2.	have only one HashBiMap data field.
12.3.	Test the new strategy in the main() method. Run the program and compare the performance
of the five strategies.


Требования:
1.	The HashBiMapStorageStrategy class must support the StorageStrategy interface.
2.	Only one HashBiMap data field should be created in the HashBiMapStorageStrategy class.
3.	The containsKey method should check whether the key is contained in data.
4.	The containsValue method should check whether the value is contained in data.
5.	The put method must add a pair (key, value) to data.
6.	The getValue method should return a value obtained from data.
7.	The getKey method should return a value obtained from data.inverse().


Shortener (12)


As you&#39;ve noticed, getting an identifier using a string takes a lot more
time than getting a string using an identifier. This is expected and is a consequence of
HashMap&#39;s implementation. Let&#39;s write a fourth strategy:
OurHashBiMapStorageStrategy, which will eliminate this shortcoming.
11.1.	Create an OurHashBiMapStorageStrategy class that implements the
StorageStrategy interface.
11.2.	Add two fields: HashMap&lt;Long, String&gt; k2v and HashMap&lt;String, Long&gt; v2k
The first will maintain a mapping from keys to values, and the second will do the opposite: from values
to keys.
11.3.	Implement the StorageStrategy interface&#39;s methods, optimizing for
speed. Hint: when a new key-value pair must be added,
add it to two fields at once.
Test the new strategy in the main() method. Run the program and compare the performance of
all 4 strategies. Be sure that we&#39;ve made it significantly faster to get
an identifier. Of course, you understand that this solution has both advantages and disadvantages.
Think about when it makes sense to use OurHashBiMapStorageStrategy and when
HashMapStorageStrategy would be preferred.



Shortener (12)


Create and implement a FileStorageStrategy class. It must:
10.1.	Implement the StorageStrategy interface.
10.2.	Use FileBucket as a buckets. Hint: The class
must have a FileBucket[] table field.
10.3.	It works like OurHashMapStorageStrategy, but
double the number of buckets not when the number of size elements becomes larger
than some threshold, but rather when the size of one of the buckets (files) became larger than
bucketSizeLimit.
10.3.1.	Add a long bucketSizeLimit field to the class.
10.3.2.	Initialize it with a default value, such as 10,000 bytes.
10.3.3.	Add a setter and getter for this field.
10.4.	When implementing the resize(int newCapacity) method, be sure that the files you no longer need
have been deleted (call the remove() method).
Test the new strategy in the main() method. Bear in mind that the FileStorageStrategy strategy is much
slower than the others. Don&#39;t use a large number of elements for the test.
Doing so could take a looooog time.
Run the program and compare the performance of all 3 strategies.

P.S. Be sure that the FileStorageStrategy class has all the necessary fields by analogy with OurHashMapStorageStrategy:
static final int DEFAULT_INITIAL_CAPACITY
static final long DEFAULT_BUCKET_SIZE_LIMIT
FileBucket[] table
int size
private long bucketSizeLimit = DEFAULT_BUCKET_SIZE_LIMIT
long maxBucketSize



Shortener (12)


Let&#39;s write another strategy. We&#39;ll call it FileStorageStrategy. It will be very similar
to OurHashMapStorageStrategy, but files will be
the buckets. I&#39;m sure you know what I mean by buckets. If not, copy the internal workings
of HashMap.
9.1.	Create a FileBucket class in the strategy package.
9.2.	Add a Path path field to the class. This will be the path to the file.
9.3.	Add a no-argument constructor to the class. It should:
9.3.1.	Initialize the path field with a temporary file. The file must be placed
in the directory for temporary files and have a random name. Hint:
Files.createTempFile.
9.3.2.	Use the path field to create a new file. If the file already exists, then
replace it.
9.3.3.	Ensure the file is deleted when you exit the program. Hint:
deleteOnExit().
9.4.	Add the following methods to the class:
9.4.1. long getFileSize() - Returns the size of the file pointed to
by path.
9.4.2. void putEntry(Entry entry) - Serializes the passed entry to
the file. Be aware that each entry may contain another entry.
9.4.3.	Entry getEntry() - Gets an entry from the file. If the file size is zero,
return null.
9.4.4. void remove() - Delete the file pointed to by path.
The constructor and methods should not throw exceptions.



Shortener (12)


Add and implement a OurHashMapStorageStrategy class, using the Entry class from the
previous subtask. The OurHashMapStorageStrategy class must implement
the StorageStrategy interface.
8.1. Add the following fields to the class:
8.1.1. static final int DEFAULT_INITIAL_CAPACITY = 16;
8.1.2. static final float DEFAULT_LOAD_FACTOR = 0.75f;
8.1.3. Entry[] table = new Entry[DEFAULT_INITIAL_CAPACITY];
8.1.4. int size;
8.1.5. int threshold = (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
8.1.6. float loadFactor = DEFAULT_LOAD_FACTOR;
8.2. Implement the following helper methods in the class:
8.2.1. int hash(Long k)
8.2.2. int indexFor(int hash, int length)
8.2.3. Entry getEntry(Long key)
8.2.4. void resize(int newCapacity)
8.2.5. void transfer(Entry[] newTable)
8.2.6. void addEntry(int hash, Long key, String value, int bucketIndex)
8.2.7. void createEntry(int hash, Long key, String value, int bucketIndex)
8.3. Add the public methods required by the StorageStrategy interface.
Don&#39;t use any additional fields. Don&#39;t implement any methods
not specified in the task. If you have questions on how to implement a
method or what it&#39;s supposed to do, you can always take a look at how the corresponding
method works in HashMap.
You can add testing of the new strategy to the Solution class&#39;s main method. Run the program
and compare the execution time of the two strategies on the same number of elements.



Shortener (12)


Let&#39;s start implementing the second strategy: OurHashMapStorageStrategy. It won&#39;t
use the ready-made HashMap from the standard library, but rather will itself be
a collection.

7.1.	Understand how the standard HashMap works. Look at its source code or
google for articles about it.
7.2.	If you really did the previous item, then you know what the
Node class, which supports the Entry interface, is used for inside HashMap. Create your own analog inside the
strategy package. This should be an ordinary, non-nested, non-generic class. Make it public.
Unlike the Node class in HashMap, our class will only support
the Serializable interface and will be called Entry.
7.3.	Add the following fields to Entry: Long key, String value, Entry next, int hash. As you can
see, our implementation will only support Long keys and
String values. Keep the default field visibility.
7.4.	Add and implement an Entry(int hash, Long key, String value, Entry next) constructor.
7.5.	Add and implement the following methods: Long getKey(), String getValue(), int hashCode(), boolean equals(), and String
toString(). Don&#39;t implement the remaining methods from the original Entry. We&#39;re
writing the simplified version.



