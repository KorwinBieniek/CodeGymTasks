taskKey="com.codegym.task.task25.task2515.big11"\n\nSpace (part 11)


Now we'll write the Rocket class.
It's almost the same as the Bomb class.
But:
a) Rockets fly upward (i.e. y is decreased by 1);
b) We'll draw 'R' instead of 'B'.


Requirements:
1.	In the Rocket class, the constructor must take coordinates, and always set the radius equal to 1.
2.	In the Rocket class, implement the move() method, which decrements the y coordinate by one.
3.	In the Rocket class, implement the draw(Canvas canvas) method, which will set the value at coordinates (x, y) equal to &#39;R&#39;.


Space (part 10)


Now we'll write the Bomb class. Everything is simple here.
Bomb inherits BaseObject.
Here's what we need:
a) change the constructor:
The Bomb constructor should look something like this:
public Bomb(double x, double y)
{
super(x, y, 1);
}
We use the super keyword to pass the x and y values passed to the Bomb constructor on to the BaseObject constructor,
where we also indicate a bomb radius equal to 1.

b) implement the move() method:
everything is simple here â€” the bomb drops downward, so just increase y by 1.

c) draw(Canvas canvas) method:
again, the logic is not very complicated here.
Let's just set the value at coordinates (x, y) to color "B":
canvas.setPoint(x, y, 'B').

d) Create a public static Space game in the Space class.



Space (part 9)


Canvas needs another two methods. Write them.
a) the clear() method();
This method will clear the matrix so it can be drawn on again.
For example, replace all characters in the matrix with spaces.

b) the print() method();
This method draws the matrix on the screen.
You should be able to figure this out on your own: Displaying a set of characters is not so difficult.
Don't forget to add a pair of blank lines at the end so that matrices displayed at different times do not run together.



Space (part 8)


What are we going to do with Canvas?
We'll draw on it (on its matrix).
Therefore, we need two methods:
public void setPoint(double x, double y, char c),
public void drawMatrix(double x, double y, int[][] matrix, char c).

The first method (setPoint) will "set a point with coordinates (x, y) to color c".
In this method, you need to:
a) round x and y to integers,
b) set matrix[y][x] to c,
c) do nothing if x < 0 or y < 0 or y >= matrix.length or x >= matrix[0].length.

The second method (drawMatrix) copies the passed image (matrix) to the Canvas matrix.
And it doesn't simply copy image, but rather it starts from coordinates (x, y).
In this method, you need to:
a) use two nested loops to go through all the "pixels" of the passed image,
b) if the value of matrix[i][j] is not 0, then paint point (x+j, y+i) the color c in the Canvas object's matrix:
setPoint(x + j, y + i, c)



Space (part 7)


Now let's tackle the Canvas class.
It will contain a matrix that we will "draw" on.
The matrix has a width and height.
And we'll use it to store characters (chars) rather than numbers (ints).
Here's what we need:
a) Add two variables (width and height) to the class;
b) Add a char[][] matrix field to the class;
c) Add getters for them;
d) Initialize the matrix in the constructor.



Space (part 6)


But there's more.
The BaseObject class needs more methods.
For now, these will be empty draw() and move() methods.
Subclasses will have to override them and implement the necessary functionality.

Also add a die() method, which causes the object to die (isAlive = false)

We'll also need to determine whether the ship was hit by a bomb hit or a UFO was hit by a missile.
This is how we'll do that:
Create a special method: public boolean intersects(BaseObject o)
It will determine whether objects intersect. If they intersect, return true; if not, false.

Because we're treating objects as circles for convenience, I propose the following collision-detection algorithm:
if the center of the circle of one object lies within the circle of another, then we'll conclude that they've collided.
Or to put it more simply:
distance_between_objects < max(radius_of_the_first_object, radius_of_the_second_object).



