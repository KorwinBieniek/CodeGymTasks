taskKey="com.codegym.task.task20.task2028.big03"\n\nBuild a tree (part 3)


We've created a class that defines a tree. Now we need a class that defines the nodes of a tree:
1) In the CustomTree class, create a static inner generic class Entry<T> with the default access modifier.
2) Make this class support the Serializable interface.
3) Declare the following fields (with the default access modifier):
- String elementName;
- boolean availableToAddLeftChildren, availableToAddRightChildren;
- Entry<T> parent, leftChild, rightChild;
- you can declare other fields, if necessary;
4) Implement a public constructor with one String parameter:
- set the field elementName equal to the passed argument;
- set the availableToAddLeftChildren field equal to true;
- set the availableToAddRightChildren field equal to true;
5) Implement the public boolean isAvailableToAddChildren method, which returns the logical disjunction (boolean OR) of the availableToAddLeftChildren and availableToAddRightChildren fields.


Requirements:
1.	The CustomTree.Entry class must be declared with the default access modifier.
2.	The CustomTree.Entry class must support the Serializable interface.
3.	There must be a String field called elementName in the CustomTree.Entry class.
4.	There must be a boolean field called availableToAddLeftChildren in the CustomTree.Entry class.
5.	There must be a boolean field called  availableToAddRightChildren in the CustomTree.Entry class.
6.	There must be an Entry field called parent in the CustomTree.Entry class.
7.	There must be an Entry field called leftChild in the CustomTree.Entry class.
8.	There must be an Entry field called rightChild in the CustomTree.Entry class.
9.	The CustomTree.Entry class must correctly implement a constructor with one String parameter (see the task conditions).
10.	The CustomTree.Entry class must correctly implement the isAvailableToAddChildren method (see the task conditions).


Build a tree (part 2)


Despite the fact that our tree descends from the AbstractList class, it is not a list in the traditional sense.
In particular, we don't have access to methods that take an element's index as an argument.
You need to override such methods and throw a new type of exception: UnsupportedOperationException.

Here's a list of them:
public String get(int index)
public String set(int index, String element)
public void add(int index, String element)
public String remove(int index)
public List<String> subList(int fromIndex, int toIndex)
protected void removeRange(int fromIndex, int toIndex)
public boolean addAll(int index, Collection<? extends String> c)



Build a tree (part 1)


Amigo, it seems you may now have an adequate foundation. It's time to test your skills by doing a big task!
Today, we'll implement our own tree in a slightly non-standard way (based on AbstractList).
To get background information, use your favorite search engine and the text below.

The nodes of the tree should be like those in the picture:
http://info.javarush.ru/uploads/images/00/04/89/2014/03/21/ee9a9b.jpg

First, let's make our tree a descendant of the AbstractList class with a String parameter, and
we'll implement the Cloneable and Serializable interfaces.

For now, leave the standard implementations of the get(int index) and size() methods.



