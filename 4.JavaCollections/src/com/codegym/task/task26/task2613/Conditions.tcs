taskKey="com.codegym.task.task26.task2613.big10"\n\nCashMachine (part 10)


Today we&#39;ll tackle WithdrawCommand. It&#39;s the most complex operation.

1. Implement the following algorithm for WithdrawCommand:
1.1. Read the currency code (the method already exists).
1.2. Get a manipulator for the specified currency.
1.3. Until the user enters valid data, do the following:
1.3.1. Ask the user to enter the amount.
1.3.2. If invalid data is entered, inform the user and return to item 1.3.
1.3.3. Check whether there&#39;s enough money in the account.
To do this, create a boolean isAmountAvailable(int expectedAmount) method in the manipulator. It should return true if there is enough money to make the withdrawal.
If there is not enough, then return to item 1.3.
1.3.4. Deduct the money from the account. To do this, in the manipulator class, create a
Map&lt;Integer, Integer&gt; withdrawAmount(int expectedAmount) that returns a Map&lt;denomination, quantity&gt;.
For details on the logic of this method, see item 2.
1.3.5. Display the result from item 1.3.4. in the following form:
&lt;tab&gt;&lt;denomination&gt; - &lt;quantity&gt;.
The lines should be sorted from larger denominations to smaller ones.
Display a message that the transaction was successful.
1.3.6. Catch InsufficientFundsExceptions, notify the user about the insufficient banknotes, and return to item 1.3.

2. Here&#39;s the logic for the withdrawAmount method:
2.1. Please note that the withdrawAmount method should return the smallest number of banknotes that can be used to provide the requested amount.
Use a greedy algorithm (google it).
If there are several options, then use the one that has the largest number of banknotes of the highest denomination.
If the result is three banknotes for a withdrawal amount of 600, i.e. 500 50 50 = 200 200 200, then issue banknotes according to the first option.
Suppose you need to issue 600.
The manipulator has the following banknotes:
500 - 2
200 - 3
100 - 1
50 - 12
The issued banknotes should be:
500 - 1
100 - 1
i.e. only two banknotes (this is the minimum number of banknotes) with the denominations 500 and 100.

2.2. We can&#39;t issue the same banknotes more than once, so
if we find a valid option for issuing the money (item 2.1 is successful), then remove all these notes from the map in the manipulator.

2.3. The withdrawAmount method should throw an InsufficientFundsException if it is impossible to issue the requested amount.
Suppose you need to issue 600.
The manipulator has the following banknotes:
500 - 2
200 - 2
The available banknotes cannot provide the requested amount. Throw an exception.
Don&#39;t forget that maps sometimes throw ConcurrentModificationExceptions.


Требования:
1.	The CurrencyManipulator class must have a boolean isAmountAvailable(int expectedAmount) method.
2.	The isAmountAvailable method should return true if there is enough money for the withdrawal.
3.	The CurrencyManipulator class must contain a Map&lt;Integer, Integer&gt; withdrawAmount(int expectedAmount) method.
4.	The withdrawAmount method should return a map according to the task conditions.
5.	The WithdrawCommand class&#39;s execute method must implement an algorithm for WithdrawCommand according to the task conditions.


CashMachine (part 10)


Today we&#39;re going to tackle ExitCommand.
1. Implement the following logic in ExitCommand:
1.1. Ask whether the user really wants to exit. Provide the following options: yes (y) or no (n).
1.2. If the user confirms, then say goodbye.
1.3. If the user does not confirm, then don&#39;t say goodbye &mdash; simply exit the program.

This is all good, but sometimes we need to urgently interrupt an operation, for example, if the user chose the wrong operation.
This is why we have InterruptedOperationException.
2. Implement the following logic:
2.1. If at any time the user enters &quot;EXIT&quot;, regardless of case, throw an InterruptedOperationException.
2.2. Find the only correct place to put this logic. Implement the functionality in this one method.

3. Wrap the body of the main method in a try-catch and handle InterruptedOperationExceptions.
Use ConsoleHelper to say goodbye to the user in the catch block.



CashMachine (part 10)


It&#39;s time to whip our main method into shape. It already has a bunch of stuff that shouldn&#39;t be there.

1. Move the logic from main to DepositCommand and InfoCommand.
So what&#39;s happened to main? We have a loop, in which we ask the user for an operation and then call a method on the CommandExecutor.
And so on forever... You need to come up the exit condition for the loop.
Correct the loop to make it a do-while. The exit condition is the EXIT operation.

2. Let&#39;s run the program and top up the account with &quot;EUR 100 2&quot; and &quot;USD 20 6&quot;. Then we&#39;ll look at INFO.
It&#39;s not clear what to do, since we&#39;ve created 2 manipulators: the first for EUR, the second for USD.
Let&#39;s improve the logic of InfoCommand. We need to display the balance for each manipulator.

2.1. In the CurrencyManipulatorFactory class, create a static getAllCurrencyManipulators() method that returns a Collection of all manipulators.
You stored all the manipulators in a map, right? If not, then refactor.
2.2. In InfoCommand, display &quot;&lt;currency code&gt; - &lt;total amount of money for the selected currency&gt;&quot;.
Let&#39;s run the program and top up the account with &quot;EUR 100 2&quot; and &quot;USD 20 6&quot;. Then we&#39;ll look at INFO.
Does everything work correctly?
EUR - 200
USD - 120
Excellent!

3. Run the program and immediately request the INFO operation as the first operation. Nothing is displayed? That&#39;s no good.
Add a boolean hasMoney() method to the manipulator. It should indicate whether any banknotes have been added.

4. In InfoCommand, use the method in item 3 and display &quot;No money available.&quot; if there is no money in the ATM.



CashMachine (part 10)


Let&#39;s return to the Command pattern.

1. Create a command package. It will contain all classes with relevant logic.
Think about the access modifier for each class in this package.

2. Create a Command interface with a void execute() method.

3. For each operation, create a command class that follows the Command pattern.
The names of these classes are DepositCommand, InfoCommand, WithdrawCommand, ExitCommand.

4. Create a public CommandExecutor class that we will use to interact with all the commands.
Create a static Map&lt;Operation, Command&gt; allKnownCommandsMap field in it. Initialize the map with all known operations and commands.

4.1 Create a public static final void execute(Operation operation) method that will call the execute method on the desired command.
Implement this logic.
4.2. Arrange access modifiers correctly, accounting for the fact that the only entry point is the execute method.

We&#39;ll check that your structure matches the tests on the server.
We&#39;ll carry the logic over to the next task.



CashMachine (part 10)


To refactor the code according to the Command pattern, you need to extract several logical blocks of code.
For now, we have two such blocks: 1) code for the DEPOSIT operation, 2) code for the INFO operation.
This code is in the main method. We need to get rid of it.
Now you need to make it so the user is the one who chooses the operation to perform.

1. Add a static Operation getAllowableOperationByOrdinal(Integer i) method to the Operation enum
It should return one of the enum&#39;s fields: 1 - INFO, 2 - DEPOSIT, 3 - WITHDRAW, 4 - EXIT;
Throw an IllegalArgumentException if invalid data is entered.

2. In the ConsoleHelper class, implement the logic for a static Operation requestOperation() method.
Ask the user to choose an operation.
If the user enters 1, execute the INFO command, 2 - DEPOSIT, 3 - WITHDRAW, 4 - EXIT;
Use the method described in item 1.
Handle any exceptions and repeat the request for an operation.



CashMachine (part 10)


1. In the previous task, we implemented the basic logic of the DEPOSIT operation.
But we couldn&#39;t see the results.
So, in the manipulator, create an int getTotalAmount() method that calculates the total amount for the selected currency.

2. Call the getTotalAmount() method in the main method.
Is everything working correctly? Then let&#39;s move right along.
Clearly, the getTotalAmount() method calculates what we need for the INFO operation.
So it&#39;s time for a little refactoring.
Read about the Command pattern!!
Before you start refactoring, you need to understand one thing. But we won&#39;t go over that just now.



