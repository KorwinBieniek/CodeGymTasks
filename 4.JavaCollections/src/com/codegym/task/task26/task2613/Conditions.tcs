taskKey="com.codegym.task.task26.task2613.big06"\n\nCashMachine (part 6)


To refactor the code according to the Command pattern, you need to extract several logical blocks of code.
For now, we have two such blocks: 1) code for the DEPOSIT operation, 2) code for the INFO operation.
This code is in the main method. We need to get rid of it.
Now you need to make it so the user is the one who chooses the operation to perform.

1. Add a static Operation getAllowableOperationByOrdinal(Integer i) method to the Operation enum
It should return one of the enum&#39;s fields: 1 - INFO, 2 - DEPOSIT, 3 - WITHDRAW, 4 - EXIT;
Throw an IllegalArgumentException if invalid data is entered.

2. In the ConsoleHelper class, implement the logic for a static Operation requestOperation() method.
Ask the user to choose an operation.
If the user enters 1, execute the INFO command, 2 - DEPOSIT, 3 - WITHDRAW, 4 - EXIT;
Use the method described in item 1.
Handle any exceptions and repeat the request for an operation.


Требования:
1.	The Operation enum must have a static getAllowableOperationByOrdinal(Integer i) method.
2.	The ConsoleHelper class must have an Operation requestOperation() method.


CashMachine (part 6)


1. In the previous task, we implemented the basic logic of the DEPOSIT operation.
But we couldn&#39;t see the results.
So, in the manipulator, create an int getTotalAmount() method that calculates the total amount for the selected currency.

2. Call the getTotalAmount() method in the main method.
Is everything working correctly? Then let&#39;s move right along.
Clearly, the getTotalAmount() method calculates what we need for the INFO operation.
So it&#39;s time for a little refactoring.
Read about the Command pattern!!
Before you start refactoring, you need to understand one thing. But we won&#39;t go over that just now.



CashMachine (part 6)


1. Let&#39;s decide what operation to start with.
Think about it. The ATM doesn&#39;t have money yet, so we can&#39;t test INFO and WITHDRAW.
We&#39;ll start with the DEPOSIT operation.
We read the currency code from the console. Then we read the denomination and number of banknotes. And then add them to the manipulator.

2. To read the currency code, add a static String requestCurrencyCode() method to ConsoleHelper.
This method should prompt the user to enter a currency code. Verify that the code contains 3 characters.
If the currency code is invalid, then inform the user and repeat.
If the currency code is valid, then convert the code to uppercase and return it.

3. To read the denomination and number of banknotes, add a static String[] method getTwoValidNumbers(String currencyCode) to ConsoleHelper.
This method should prompt the user to enter two positive integers.
The first number is the denomination. The second is the number of banknotes.
There is no validation of the denomination. That is, 1200 is an acceptable denomination.
If the currency code is invalid, then inform the user and repeat.
Example input:
200 5

4. In the CurrencyManipulator class, create a void addAmount(int denomination, int count) method
that adds banknotes in the specified denomination and quantity.

5. It&#39;s time to see the application in action.
In the main method, write the code to implement the logic described in item 1.
By the way, to avoid problems with testing the server, add &quot;Locale.setDefault(Locale.ENGLISH);&quot; as the first line in the main method.
Let&#39;s start it, debug it, and check it out.



CashMachine (part 6)


1. Create CurrencyManipulator class that stores all the information about the selected currency.
The class must have:
1.1 String currencyCode &mdash; currency code, i.e. USD. It consists of three letters.
1.2 Map&lt;Integer, Integer&gt; denominations is a map of (denomination, quantity) pairs.
To see which currency is associated with the manipulator, add a getter for currencyCode.
Obviously, the manipulator can&#39;t function without the currency&#39;s name,
so add a constructor with this parameter and initialize currencyCode.

2. There may be several currencies, so we need a factory to create and store the manipulators.
Create a CurrencyManipulatorFactory class with the static getManipulatorByCurrencyCode(String currencyCode) method.
In this method, we&#39;ll create the relevant manipulator if it doesn&#39;t already exist, or return a previously created one.
Ignore case when searching for a currency manipulator.
Where do you think the best place to store all the manipulators would be?  Here&#39;s a little hint: the field should be called map.

Make it impossible to create CurrencyManipulatorFactory objects.



CashMachine (part 6)


1. Create two static methods in ConsoleHelper:
1.1 writeMessage(String message), which will write our message to the console.
1.2 String readString(), which will read a string from the console and return it.
If some exception occurs when working with the console, then we&#39;ll catch it and won&#39;t process the input.
By the way, create only one instance of BufferedReader, and save it in the static bis field.

2. Create an exception package, where we will put two checked exceptions:
2.1 We&#39;ll throw an InterruptedOperationException will be thrown when you need to interrupt the current operation and sign out of the application.
2.2 InsufficientFundsException will throw when we can not issue the requested amount.



CashMachine (part 6)


Let&#39;s write an ATM emulator.
We will support the following operations:
deposit money, withdraw money, and show the status of the ATM.
We will also support multiple currencies.
The ATM will operate using the banknotes we put into it.
If there are insufficient banknotes to make a withdrawal, then we will inform the user.
Obviously, everything should be user friendly, so you&#39;ll have to arrange things just right.

Let&#39;s begin:
1. Create a CashMachine class with the main method.
2. We&#39;ll specify the supported operations in an Operation enum: INFO, DEPOSIT, WITHDRAW.
Since everything needs to be user friendly, we&#39;ll say goodbye to the user when the application closes.
Therefore, we&#39;ll add another operation: EXIT.
3. We&#39;ll be actively communicating with with the user, so there will be a lot of text output.
To concentrate the code for working with the console in one place, create a ConsoleHelper class.



