taskKey="com.codegym.task.task34.task3410.big15"\n\nSokoban (part 15)


The time has come to implement the model&#39;s move() method, which is responsible for movement. But first,
let&#39;s implement some helper methods. Add the following methods to the Model class:
15.1. boolean checkWallCollision(CollisionObject gameObject, Direction direction). This
method checks for collisions with a wall. It should return true if the gameObject will collide
with a wall by moving in the passed direction;
otherwise, it should return false. To determine if there is a collision, use the game object&#39;s
isCollision() method.
15.2. boolean checkBoxCollisionAndMoveIfAvailable(Direction direction). This method checks for
collisions with boxes. The method should:
15.2.1. Return true if the player can&#39;t move in the specified direction (i.e. the cell is occupied by
a box with a wall behind it or by a box with another box behind it).
15.2.2. Return false if the player can move in the specified direction (i.e. the cell is occupied by
an empty cell or by a storage location or by a box with an empty
cell or a storage location behind it). In this case, if a movable box is in the way, then
you need to move it to new coordinates. Note that
all the objects move by a fixed distance equal to BOARD_CELL_SIZE regardless
of the dimensions used for drawing.
Hint: check for collisions using the game objects&#39; isCollision() methods
and the model&#39;s checkWallCollision() method.
15.3. void checkCompletion(). This method must check whether the level has been completed (whether
all the storage locations have boxes on them, i.e. their coordinates match). If this condition
is true, then let the event listener know that the current level is complete.
15.4. void move(Direction direction). The method should:
15.4.1. Check for a wall collision (use the checkWallCollision() method). If there is a
collision, then exit the method.
15.4.2. Check for a box collision (use the checkBoxCollisionAndMoveIfAvailable() method). If there is a
collision, then exit the method.
15.4.3. Move the player in the passed direction.
15.4.4. Check whether the level is completed.

Run the program and be sure that the player can move itself and
boxes, that walls prevent the player from moving, and that when you move all the boxes onto storage locations that a message about
completing the level is displayed.


Требования:
1.	Implement the boolean checkWallCollision(CollisionObject gameObject, Direction direction) method in the Model class.
2.	Implement the boolean checkBoxCollisionAndMoveIfAvailable(Direction direction) method in the Model class.
3.	Implement the void checkCompletion() method in the Model class.
4.	Implement the void move(Direction direction) method in the Model class.


Sokoban (part 15)


Let&#39;s make our game more interactive (using a keyboard
to move the player). We&#39;ll start by handling keystrokes.
14.1. Add to the Board class a nested KeyHandler class that
inherits KeyAdapter.
14.2. Overload its keyPressed() method. If the key with code VK_LEFT is pressed,
then send an event with a Direction.LEFT argument to eventListener.
Handle keystrokes with codes VK_RIGHT, VK_UP, and
VK_DOWN in a similar manner. If the user presses the R key, which has code VK_R, then call the event
listener&#39;s restart() method.
14.3. In the Board class constructor:
14.3.1. Create a KeyHandler object.
14.3.2. Use the addKeyListener() method to the handler to the listener.
14.3.3. Set focusable to true (using the setFocusable() method).



Sokoban (part 15)


Let&#39;s fill out the controller&#39;s functionality.
13.1. In addition to what the Controller class constructor already has, add event listeners
on the model and view. The controller must itself be a listener.
13.2. Implement the controller&#39;s methods:
13.2.1. move(Direction direction) - should call the model&#39;s move(Direction direction) method
and the view&#39;s update() method. The model doesn&#39;t have a move() method yet. Add a
stub for it. We&#39;ll implement it later.
13.2.2. restart() - must restart the model and update the view.
13.2.3. startNextLevel() - must start a new level on the model and update
the view.
13.3. Add to the view a completed(int level) method that lets the user know
when a level has been completed. The method should:
13.3.1. Update the view.
13.3.2. Show a dialog box with a message saying that the user has completed
a level. Hint: use JOptionPane.showMessageDialog.
13.3.3. Ask the controller to start the next level.
13.4. Implement the levelCompleted(int level) method in the controller. It should call
the view&#39;s completed() method.



Sokoban (part 15)


Let&#39;s try organizing the interaction between the view and model.
12.1. Add an update() method to the View class. It must call the repaint() method on the
board field. In other words, the update() method will update the view
(redraw the board).
12.2. Add the GameObjects getGameObjects() method to the controller class. It must
request game objects from the model and return them. Add the same method to the view class.
It should get objects from the controller.
12.3. Properly implement the paint(Graphics g) method in the Board class. It must:
12.3.1. Fill the entire board with some color such as black (call the setColor and
fillRect methods).
12.3.2. Get all the game objects from the view.
12.3.3. Draw all the game objects.
12.4. The Controller must restart the model in its constructor.


Run the program and be sure that all of the game objects are drawn correctly.



Sokoban (part 15)


Let&#39;s begin fleshing out the Model class&#39; functionality. Add the following:
11.1. A GameObjects gameObjects field. It will store our game objects.
11.2. An int currentLevel field that stores the current level. Initialize it
to 1.
11.3. A LevelLoader levelLoader field that stores the level loader.
Initialize it using the levels.txt file from the res folder.
11.4. A GameObjects getGameObjects() method that must return all of the game
objects.
11.5. A restartLevel(int level) method that must receive the new game objects
from levelLoader for the specified level and save them in the gameObjects field.
11.6. The restart() method must restart the current level by calling restartLevel
with the appropriate argument.
11.7. The startNextLevel() method must increase the value of the
currentLevel variable, which stores the current level number, and restart the new level.



Sokoban (part 15)


The game will have several levels, and all of them will be stored in a text file. Now we&#39;ll
write a LevelLoader test stub. Why a test stub? We don&#39;t
need the full functionality yet. It&#39;s pretty complicated, so we&#39;ll leave it for later. For now:
10.1. Create a LevelLoader class in the model package.
10.2. Add a constructor that accepts a Path levels argument. The levels parameter is
the path to the test file containing the level descriptions.
10.3. Add the GameObjects getLevel(int level) method to the LevelLoader class. For now, it doesn&#39;t
matter what this method returns. For now, have it always return a set with: one player,
one storage location, one box, and several walls. That will make it easier to debug the game.
The coordinates of each object must be non-zero and multiples of half of
BOARD_CELL_SIZE (the center of each object must be in the middle of a cell).



