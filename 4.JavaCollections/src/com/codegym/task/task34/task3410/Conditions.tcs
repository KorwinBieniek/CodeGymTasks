taskKey="com.codegym.task.task34.task3410.big13"\n\nSokoban (part 13)


Let&#39;s fill out the controller&#39;s functionality.
13.1. In addition to what the Controller class constructor already has, add event listeners
on the model and view. The controller must itself be a listener.
13.2. Implement the controller&#39;s methods:
13.2.1. move(Direction direction) - should call the model&#39;s move(Direction direction) method
and the view&#39;s update() method. The model doesn&#39;t have a move() method yet. Add a
stub for it. We&#39;ll implement it later.
13.2.2. restart() - must restart the model and update the view.
13.2.3. startNextLevel() - must start a new level on the model and update
the view.
13.3. Add to the view a completed(int level) method that lets the user know
when a level has been completed. The method should:
13.3.1. Update the view.
13.3.2. Show a dialog box with a message saying that the user has completed
a level. Hint: use JOptionPane.showMessageDialog.
13.3.3. Ask the controller to start the next level.
13.4. Implement the levelCompleted(int level) method in the controller. It should call
the view&#39;s completed() method.


Требования:
1.	The Controller class constructor should set up an event listener for the model and view.
2.	Implement the controller&#39;s move(Direction direction) method.
3.	Implement the controller&#39;s restart() method.
4.	Implement the controller&#39;s startNextLevel() method.
5.	Implement the view&#39;s completed(int level) method.
6.	Implement the controller&#39;s levelCompleted(int level) method.


Sokoban (part 13)


Let&#39;s try organizing the interaction between the view and model.
12.1. Add an update() method to the View class. It must call the repaint() method on the
board field. In other words, the update() method will update the view
(redraw the board).
12.2. Add the GameObjects getGameObjects() method to the controller class. It must
request game objects from the model and return them. Add the same method to the view class.
It should get objects from the controller.
12.3. Properly implement the paint(Graphics g) method in the Board class. It must:
12.3.1. Fill the entire board with some color such as black (call the setColor and
fillRect methods).
12.3.2. Get all the game objects from the view.
12.3.3. Draw all the game objects.
12.4. The Controller must restart the model in its constructor.


Run the program and be sure that all of the game objects are drawn correctly.



Sokoban (part 13)


Let&#39;s begin fleshing out the Model class&#39; functionality. Add the following:
11.1. A GameObjects gameObjects field. It will store our game objects.
11.2. An int currentLevel field that stores the current level. Initialize it
to 1.
11.3. A LevelLoader levelLoader field that stores the level loader.
Initialize it using the levels.txt file from the res folder.
11.4. A GameObjects getGameObjects() method that must return all of the game
objects.
11.5. A restartLevel(int level) method that must receive the new game objects
from levelLoader for the specified level and save them in the gameObjects field.
11.6. The restart() method must restart the current level by calling restartLevel
with the appropriate argument.
11.7. The startNextLevel() method must increase the value of the
currentLevel variable, which stores the current level number, and restart the new level.



Sokoban (part 13)


The game will have several levels, and all of them will be stored in a text file. Now we&#39;ll
write a LevelLoader test stub. Why a test stub? We don&#39;t
need the full functionality yet. It&#39;s pretty complicated, so we&#39;ll leave it for later. For now:
10.1. Create a LevelLoader class in the model package.
10.2. Add a constructor that accepts a Path levels argument. The levels parameter is
the path to the test file containing the level descriptions.
10.3. Add the GameObjects getLevel(int level) method to the LevelLoader class. For now, it doesn&#39;t
matter what this method returns. For now, have it always return a set with: one player,
one storage location, one box, and several walls. That will make it easier to debug the game.
The coordinates of each object must be non-zero and multiples of half of
BOARD_CELL_SIZE (the center of each object must be in the middle of a cell).



Sokoban (part 13)


Various events will occur during the game. Let&#39;s create an
EventListener interface. Every class that wants to handle events must
implement it. And classes that generate events will call
this interface&#39;s methods.
9.1. Add the EventListener interface to the controller package.
9.2. Add these void methods to the interface:
9.2.1. move(Direction direction) - moves the object in the specified direction.
9.2.2. restart() - restart the current level.
9.2.3. startNextLevel() - start the next level.
9.2.4. levelCompleted(int level) - the level with the passed index has been completed.
9.3. Add the EventListener interface to the Controller class, and write the stubs required to
implement the interface.
9.4. Add an EventListener eventListener field to the Model and Board classes.
9.5. Add the setEventListener(EventListener eventListener) method
to the Model, View, and Board classes. In the View class, this method must call the analogous method on the
board object. In the Model and Field classes, it must set the value of the internal eventListener fields.



Sokoban (part 13)


You&#39;ve created the complete collection of game objects. Let&#39;s create a class to
store these objects.
8.1. Create a GameObjects class in the model package.
8.2. Add the following:
8.2.1. Set&lt;Wall&gt; walls, Set&lt;Box&gt; boxes, Set&lt;StorageLocation&gt; storageLocations, and Player player fields.
8.2.2. Getters for these fields.
8.2.3. A class constructor that accepts Set&lt;Wall&gt; walls, Set&lt;Box&gt; boxes, Set&lt;StorageLocation&gt; storageLocations,
and Player player arguments, and that initializes the class&#39;s fields.
8.2.4. A Set&lt;GameObject&gt; getAll() method. It must return a set containing
all of the objects stored in the object.




