taskKey="com.codegym.task.task34.task3410.big04"\n\nSokoban (part 4)


We already have a shared GameObject class. It&#39;s time to create classes
for specific types of game objects.
4.1. Some game objects can move (player and boxes) and some can&#39;t (walls
and storage locations).
4.1.1. Add the Movable interface to the model package.
4.1.2. The Movable interface must have a void move(int x, int y) method.
4.2. Add a Direction enum to the model package. It must have the following values:
LEFT, RIGHT, UP, and DOWN. This type will be used to describe the direction
of an object&#39;s movement.
4.3. The &quot;storage location&quot; objects don&#39;t support collision detection (the player and
boxes can freely move over them). As for other objects,
they must not pass through one another, i.e. they should collide. For example,
a box can&#39;t be pushed through a wall.
4.3.1. Add an abstract CollisionObject class to the model package.
3.4.2. The CollisionObject class must inherit GameObject.
4.3.3. Add the following to the CollisionObject class:
4.3.3.1. A constructor that accepts int x and int y arguments.
4.3.3.2. A boolean isCollision(GameObject gameObject, Direction direction) method.
This method should return true if the current
object will collide with the gameObject parameter after moving a distance of BOARD_CELL_SIZE
in the direction specified by the direction parameter.
Otherwise, it should return false. If (x, y) coordinates match, you have a collision.


Требования:
1.	Add a Movable interface to the model package.
2.	The Movable interface must declare a void move(int x, int y) method.
3.	Add a Direction enum to the model package. It must have the following values: LEFT, RIGHT, UP, and DOWN.
4.	Add an abstract CollisionObject class to the model package.
5.	The CollisionObject class must inherit GameObject.
6.	Add a CollisionObject class constructor that accepts int x and int y arguments.
7.	Add a boolean isCollision(GameObject gameObject, Direction direction) method to the CollisionObject class. It must implement the behavior described in the task conditions.


Sokoban (part 4)


Soon we&#39;ll be creating various game objects. It would be handy to be able
to draw them somewhere right away and see how they look. Objects will be
drawn on the game board represented by a Board object.
You&#39;ve received modified code for the View class that creates a Board object and
sets up the view properly. You will also need:
3.1. Add to the view package a Board class that inherits JPanel.
3.2. Add the following to the Board class:
3.2.1. A constructor with a View view parameter.
3.2.2. A View view field that must be initialized in the constructor.
3.2.3. Create a stub for a paint(Graphics g) method. It won&#39;t do anything yet.
3.3. Add a call to the view&#39;s init() method to the Controller class constructor.
3.4. The Controller class&#39;s main() method must create a new Controller object.



Sokoban (part 4)


The foundation is laid, so now let&#39;s start building. You can think of the gameplay
as the interaction of GameObject objects. We&#39;ll have several types of them:
Box, StorageLocation (the place where you need to put the box), Wall, and Player.
2.1. Add an abstract GameObject class to the model package.
2.2. Add the following fields to the GameObject class: int x, int y, int width, and int height. These fields represent the position and
size of the object when drawn.
2.3. Add setters and getters for the class&#39;s fields.
2.4. Add to the Model class a public static int BOARD_CELL_SIZE = 20 constant. This
represents the size of cells on the game board. All game objects will occupy one cell
of the game board. This is the size that will be used when calculating movement and
object collisions. The size stored inside an object will only be
used when drawing that object.
2.5. Add two constructors to the GameObject class:
2.5.1. GameObject(int x, int y)
2.5.2. GameObject(int x, int y, int width, int height)
The constructors must initialize all of the class&#39;s fields. If width and height aren&#39;t passed,
then use BOARD_CELL_SIZE as the width and height.
2.6. Add an abstract void draw(Graphics graphics) method to the GameObject class. This method
will be implemented differently in each type of game object. In other words,
each type of game object will know how it should be drawn and will
draw itself in the graphics context. Graphics is an abstract class from the
java.awt library.



Sokoban (part 4)


Today we&#39;re going to write our own implementation of the game Sokoban. This is a logical puzzle game.
You can read more about it on Wikipedia. The game will consist of 3
main components (as you may have guessed, you&#39;ll need the MVC pattern).
The graphical interface will be implemented using Swing.
1.1. Create a view package and add a View class that inherits JFrame. This class
will be responsible for displaying our game.
1.2. Create a model package and add a Model class. This class will be responsible for our game&#39;s
model. How do you like the class names? Totally unpredictable, right? :) Actually,
it&#39;s very important to name classes in a way that allows anyone seeing your project for the first time
to immediately understand what the classes are responsible for.
1.3. Create a controller package and add a Controller class with a default constructor.
1.4. Add a View class constructor that accept a Controller and saves it
in a field inside the class (which you will also need to add). Name the field &quot;controller&quot;.
1.5. Add View view and Model model fields to the Controller class. Initialize them in
the constructor.
1.6. Since the controller is our main class, add the main method to it.



