taskKey="com.codegym.task.task24.task2413.big15"\n\nArkanoid (part 15)


You won't believe it, but we're still not done.

First, you need a setDirection method,
which not only sets the value of the direction variable,
but also computes the new values ​​of the dx and dy variables.

The code should look something like this:
this.direction = direction;
double angle = Math.toRadians(direction);
dx = Math.cos(angle) * speed;
dy = -Math.sin(angle) * speed.

Second, the ball can hit a wall.
If it does, then it should bounce off.
For this, we need one more method:
void checkRebound(int minx, int maxx, int miny, int maxy)
Declare it, and I'll handle the code myself.


Requirements:
1.	A setDirection() method with one double parameter must be created in the Ball class (see the implementation in the task conditions).
2.	A checkRebound method with four int parameters must be created in the Ball class.


Arkanoid (part 14)


The Ball class is missing something:

First, you need to implement the move() method inherited from BaseObject:
a) x should increase by dx each turn
b) y must increase by dy each turn
If the ball is frozen, then x and y should not change

Second, you need to implement the draw(Canvas canvas) method:
You need to call the canvas object's setPoint method with arguments (x, y, 'O')

Third, you need to implement the start() method
This call "thaws" the ball.
You decide for yourself what you need to do to accomplish this.

P.S. Oh, I almost forgot! The x, y, and radius fields are declared with the private access modifier in the BaseObject class,
which isn't very convenient. Change the modifier to protected so that all of the BaseObject class's descendants can control their own
coordinates and dimensions without the need to use "foreign" getters and setters.



Arkanoid (part 13)


The Ball class is more complicated, since the ball moves.

We're going to need private fields:
a) double speed (the ball's speed);
b) double direction (the direction of motion in degrees: from 0 to 360);
c) double dx (the distance along the x axis that the ball travels in one step, calculated using speed and direction);
d) double dy (the distance along the y axis that the ball travels in one step, calculated using speed and direction);
e) boolean isFrozen (true if the ball is "frozen", i.e. not moving).

Don't forget to add getters for all the fields of this class, except isFrozen (we'll only be using it inside the Ball class).

And we'll also make a constructor:
a) parameters—x, y, speed, direction;
b) radius (for calling the parent class) is always 1;
c) don't forget to set isFrozen to true—the ball isn't flying anywhere at the beginning of the game.



Arkanoid (part 12)


Now let's tackle the Brick class.

First, in the constructor we will set the exact "radius" of all the bricks.
Let's do it like this:
public Brick(double x, double y) {
super(x, y, 3);
}

Also be sure that the Brick class has two overridden methods: move() and draw(Canvas canvas).
The move() method does nothing (it contains no code), because a brick doesn't move anywhere.

I'll handle the draw(Canvas canvas) method's code myself.



Arkanoid (part 11)


Canvas needs another two methods. Write them.
a) the clear() method
This method will clear the matrix so it can be drawn on again.
You can just re-initialize the matrix with an empty array of the correct dimensions.

b) the print() method
This method draws the matrix on the screen.
You should be able to figure this out on your own: Displaying a set of characters is not so difficult.



Arkanoid (part 10)


What are we going to do with Canvas?
We'll draw on it (on its matrix).
Therefore, we need two methods:
void setPoint(double x, double y, char c)
void drawMatrix(double x, double y, int[][] matrix, char c)

The first method (setPoint) will "set a point with coordinates (x, y) to color c".
In this method, you need to:
a) round x and y to integers
b) set matrix[y][x] to c
c) do nothing if x < 0 or y < 0 or y > matrix.length or x > matrix[0].length

The second method (drawMatrix) copies the passed image (matrix) to the Canvas matrix.
And it doesn't simply copy image, but rather it starts from coordinates (x, y)
In this method, you need to:
a) use two nested loops to go through all the "pixels" of the passed image
b) if the value of element [i][j] of the passed matrix is ​​not 0, then paint point (x+j, y+i) the color c in the Canvas object's matrix:
setPoint(x + j, y + i, c)




