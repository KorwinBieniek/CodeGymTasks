taskKey="com.codegym.task.task24.task2413.big13"\n\nArkanoid (part 13)


The Ball class is more complicated, since the ball moves.

We're going to need private fields:
a) double speed (the ball's speed);
b) double direction (the direction of motion in degrees: from 0 to 360);
c) double dx (the distance along the x axis that the ball travels in one step, calculated using speed and direction);
d) double dy (the distance along the y axis that the ball travels in one step, calculated using speed and direction);
e) boolean isFrozen (true if the ball is "frozen", i.e. not moving).

Don't forget to add getters for all the fields of this class, except isFrozen (we'll only be using it inside the Ball class).

And we'll also make a constructor:
a) parameters—x, y, speed, direction;
b) radius (for calling the parent class) is always 1;
c) don't forget to set isFrozen to true—the ball isn't flying anywhere at the beginning of the game.


Requirements:
1.	A private double speed field must be created in the Ball class.
2.	A private double direction field must be created in the Ball class.
3.	A private double dx field must be created in the Ball class.
4.	A private double dy field must be created in the Ball class.
5.	A private boolean isFrozen field must be created in the Ball class.
6.	A public constructor must be created in the Ball class (the behavior and parameters are described in the task conditions).
7.	There must be a proper public getter for the speed field in the Ball class.
8.	There must be a proper public getter for the direction field in the Ball class.
9.	There must be a proper public getter for the dx field in the Ball class.
10.	There must be a proper public getter for the dy field in the Ball class.


Arkanoid (part 12)


Now let's tackle the Brick class.

First, in the constructor we will set the exact "radius" of all the bricks.
Let's do it like this:
public Brick(double x, double y) {
super(x, y, 3);
}

Also be sure that the Brick class has two overridden methods: move() and draw(Canvas canvas).
The move() method does nothing (it contains no code), because a brick doesn't move anywhere.

I'll handle the draw(Canvas canvas) method's code myself.



Arkanoid (part 11)


Canvas needs another two methods. Write them.
a) the clear() method
This method will clear the matrix so it can be drawn on again.
You can just re-initialize the matrix with an empty array of the correct dimensions.

b) the print() method
This method draws the matrix on the screen.
You should be able to figure this out on your own: Displaying a set of characters is not so difficult.



Arkanoid (part 10)


What are we going to do with Canvas?
We'll draw on it (on its matrix).
Therefore, we need two methods:
void setPoint(double x, double y, char c)
void drawMatrix(double x, double y, int[][] matrix, char c)

The first method (setPoint) will "set a point with coordinates (x, y) to color c".
In this method, you need to:
a) round x and y to integers
b) set matrix[y][x] to c
c) do nothing if x < 0 or y < 0 or y > matrix.length or x > matrix[0].length

The second method (drawMatrix) copies the passed image (matrix) to the Canvas matrix.
And it doesn't simply copy image, but rather it starts from coordinates (x, y)
In this method, you need to:
a) use two nested loops to go through all the "pixels" of the passed image
b) if the value of element [i][j] of the passed matrix is ​​not 0, then paint point (x+j, y+i) the color c in the Canvas object's matrix:
setPoint(x + j, y + i, c)




Arkanoid (part 9)


Now let's tackle the Canvas class.
It will contain a matrix (two-dimensional array) that we will "draw" on.
The matrix has a width and height.
And we'll use it to store characters (chars) rather than numbers (ints).

Here's what we need:
a) Add two private width and height fields to the class.
b) Add a private char[][] matrix field to the class.
c) Add a constructor with two int parameters (width and height). The matrix field must be initialized with an empty [height+2][width+2] array.
d) Add getters and setters for all of the class's private fields.




Arkanoid (part 8)


But there's more.
The BaseObject class needs more methods.
For now, these will be empty draw(Canvas canvas) and move() methods.
Subclasses will have to override them and implement the necessary functionality (you can leave them empty for now—we just need the code to compile).
Declare these methods, but make them abstract.
Also, make the BaseObject class itself abstract.

And we'll need to determine whether the ball hit a brick or the paddle.
This is how we'll do that:
In this same class, we'll create a special method: boolean intersects(BaseObject o)
It will determine whether objects intersect. If they intersect, return true; if not, false.

Because we're treating objects as circles for convenience, I propose the following collision-detection algorithm:
If the center of the circle of one object lies within the circle of another, then we'll conclude that they've collided.
Or to put it more simply:
distance_between_objects <= max(radius_of_the_first_object, radius_of_the_second_object)



