taskKey="com.codegym.task.task24.task2413.big18"\n\nArkanoid (part 18)


Now we'll return to the Arkanoid class.

Implement the following methods:
a) move()
In this method, you need to move all movable objects (the paddle and ball).
b) draw(Canvas canvas)
In this method, you must call the draw method on all objects that have such a method.


Requirements:
1.	The Arkanoid class must implement a move() method without parameters. This method calls the move() method on the ball and paddle.
2.	The Arkanoid class must implement a draw(Canvas canvas) method that calls the draw method on the ball, paddle, and all bricks.


Arkanoid (part 17)


The paddle also needs methods:
a) move - see move in BaseObject
The paddle moves horizontally, so we'll only change the x coordinate.
Think about how the x coordinate depends on direction and speed. Implement that dependence.
b) draw - see draw in BaseObject
I'll handle the code myself.
c) moveLeft() - sets the paddle's direction to left
Just assign the correct value to the direction variable.
d) moveRight () - sets the paddle's direction to right
Just assign the correct value to the direction variable.



Arkanoid (part 16)


And finally, the paddle!
It will need the following private fields:
a) double speed (the paddle's speed);
b) direction (direction of movement along the x axis: 1 - to the right, -1 - to the left, 0 (initial value) - hold still).

Also, create getters for them.

And you'll need to make a constructor, something like this:
public Paddle(double x, double y) {
super(x, y, 3);
speed = 1;
direction = 0;
}



Arkanoid (part 15)


You won't believe it, but we're still not done.

First, you need a setDirection method,
which not only sets the value of the direction variable,
but also computes the new values ​​of the dx and dy variables.

The code should look something like this:
this.direction = direction;
double angle = Math.toRadians(direction);
dx = Math.cos(angle) * speed;
dy = -Math.sin(angle) * speed.

Second, the ball can hit a wall.
If it does, then it should bounce off.
For this, we need one more method:
void checkRebound(int minx, int maxx, int miny, int maxy)
Declare it, and I'll handle the code myself.



Arkanoid (part 14)


The Ball class is missing something:

First, you need to implement the move() method inherited from BaseObject:
a) x should increase by dx each turn
b) y must increase by dy each turn
If the ball is frozen, then x and y should not change

Second, you need to implement the draw(Canvas canvas) method:
You need to call the canvas object's setPoint method with arguments (x, y, 'O')

Third, you need to implement the start() method
This call "thaws" the ball.
You decide for yourself what you need to do to accomplish this.

P.S. Oh, I almost forgot! The x, y, and radius fields are declared with the private access modifier in the BaseObject class,
which isn't very convenient. Change the modifier to protected so that all of the BaseObject class's descendants can control their own
coordinates and dimensions without the need to use "foreign" getters and setters.



Arkanoid (part 13)


The Ball class is more complicated, since the ball moves.

We're going to need private fields:
a) double speed (the ball's speed);
b) double direction (the direction of motion in degrees: from 0 to 360);
c) double dx (the distance along the x axis that the ball travels in one step, calculated using speed and direction);
d) double dy (the distance along the y axis that the ball travels in one step, calculated using speed and direction);
e) boolean isFrozen (true if the ball is "frozen", i.e. not moving).

Don't forget to add getters for all the fields of this class, except isFrozen (we'll only be using it inside the Ball class).

And we'll also make a constructor:
a) parameters—x, y, speed, direction;
b) radius (for calling the parent class) is always 1;
c) don't forget to set isFrozen to true—the ball isn't flying anywhere at the beginning of the game.



