taskKey="com.codegym.task.task35.task3513.big14"\n\n2048 (part 14)


A random move is certainly not bad, but it's much cooler to implement the ability to make smart moves. We won't get bogged down in neural networks.
To start, we'll focus on a fairly simple idea.

Obviously, a good move should eventually bring us closer to victory, namely, a tile with 2048.
I propose the following option for comparing the fitness of different moves:
1) Move 1 is better than Move 2 if it results in more empty tiles on the board
than Move 2.
2) Move 1 is better than Move 2 if it results in a higher total score than
Move 2.

To make this comparison, we can make a move, evaluate its fitness, and then
undo the move to return the game to its initial state. Applying this sequence of actions
to all four movement options, we can identify the best move and execute it.

Conceptually, we need two classes: one to describe the move, and another to describe its fitness.

Create a Move interface with one void move method. Annotate the interface with the @FunctionalInterface annotation type, which
indicates that there will be only one abstract method in this interface.

Create a MoveFitness class that describes the fitness of the move. It will need to have private int
numberOfEmptyTiles and scores fields, as well as a private Move move field.
The MoveFitness class needs a constructor with three parameters (int numberOfEmptyTiles, int score, Move move)
for initializing the fields, and a getter for the move field.


Requirements:
1.	The Move interface must have one abstract void move method.
2.	The Move interface must be annotated with the @FunctionInterface annotation type.
3.	The MoveFitness class constructor must correctly initialize the object&#39;s fields.
4.	A proper getter for the move field must be created in the MoveFitness class.


2048 (part 13)


Your progress is impressive! To change things up, I suggest giving the game the ability to
choose the next move on its own.

Let's start with the simple. In the Model class, implement a randomMove that randomly calls one of the movement
methods. You can implement this by calculating n = ((int) (Math.random () * 100)) % 4.
The resulting number will be a pseudorandom integer in the range [0..3]. You can associate each number in this range
with one of the methods left, right, up, or down.

Don't forget to add a call to the randomMove method in the Controller class's keyPressed method in response to a press of the R key
(code - KeyEvent.VK_R).

P.S. I'll leave you entirely responsible for checking the correctness of the randomMove method.
I'll only check for the presence of a call to the Math.random() method.



2048 (part 12)


Well, shall we try our algorithm in action? We still need to add logic to save the game state at the beginning of each
movement method, as well as another key processing case for undoing the last move.

When saving the current state to the stack, be sure that the current state is always saved
and only once. If you listened to my advice and used rotations and a call to the left method
to implement the right, up, and down method, you can use the following approach:
1) At the very beginning of the right, up, and down methods, call the saveState method with gameTiles as the argument.
2) In the left method, check whether the saveState method has already been called. We have the isSaveNeeded flag
for this. If it is true, we save the state. After performing
a left shift, we set the isSaveNeeded flag to true.

Also, make the Controller class's keyPressed method call the rollback method when the Z key (code KeyEvent.VK_Z) is pressed.



2048 (part 11)


Good work! At this stage, we already have a full-featured application, but there’s no limit to perfection.
Let's do some more work.

If you've managed to play 2048 a little, you've noticed that sometimes you really want to be able to undo
your last move.

Let's create two stacks in the Model class: one to store the previous states of the game board, and the other
to store previous scores. Let's call them previousStates and previousScores. You can initialize them immediately when they are declared
or in the constructor. Use the standard stack implementation (java.util.Stack).

Add a boolean isSaveNeeded field and set it to true. We'll need it in the future.

We have places to store state. Now we'll implement two methods to work with them.
1. The private saveState method with one Tile[][] parameter will use the push method to save the current
game board and score in stacks and set the isSaveNeeded flag to false.
2. The public rollback method will use the pop method to set the current game state to the last state
added to the stacks.

Note that when you save the gameTiles array, you need to create a new array and populate it
with new Tile objects before saving it to the stack.

In the rollback method, perform a simple assignment (gameTiles = previousStates.pop()) and do the same for the score.
There's no need for a deep copy.

Before restoring the game state using the rollback method, don't forget to check whether the stacks are empty
to avoid throwing an EmptyStackException.



2048 (part 10)


It's time to start implementing the main method in the Main class—to finally be able to launch the game and relax!

We only need the main method to run the application. We've already implemented all the guts.
To do this, in the main method, we'll create a model and controller, as well as a JFrame object. I'll call it game,
but you can choose any name you want.

We will need to call some methods on our game (JFrame object) in order for everything to be displayed correctly
on the screen:

game.setTitle("2048");
game.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
game.setSize(450, 500);
game.setResizable(false);

game.add(controller.getView());

game.setLocationRelativeTo(null);
game.setVisible(true);

Pay attention to the add method to which we pass the view from the controller. We don't yet have a getter for the view field
in the Controller class. Don't forget to add it.

P.S. Finishing this task will result in a working version of the game 2048. If something doesn't work,
or doesn't work as expected, be sure to figure it out and fix it before moving on to the subsequent tasks.



2048 (part 9)


You're doing really well! It's so good that I decided to help you a little and have already implemented the View class.
It's quite simple. It inherits the JPanel class, overrides the paint method, and displays
the current state of the model obtained using the controller.

But you have to finish implementing the Controller class.

To start, we're going to need a constructor. It will have one Model parameter, initialize the model
field, and also save a new View object in the view field, passing the current controller (this) to the
constructor.

Next, we need a resetGame method that can return the game board to its initial state.
You need to reset the score, set the isGameWon and isGameLost flags on the view to false, and call the
resetGameTiles method on the model. Note: set the field values directly, without using setters.

Add a private constant int WINNING_TILE = 2048. It will determine the tile weight that, when achieved,
constitutes a win.

And now, the most important thing! To be able to process user input, you need to
override the keyPressed method with a single KeyEvent parameter.
The logic of the method should be as follows:
1) If the ESC key was pressed, call the resetGame method.
2) If the model's canMove method returns false, set the isGameLost flag to true.
3) If both the isGameLost and isGameWon flags are false, process the movement events:
a) for KeyEvent.VK_LEFT, call the left method on the model;
b) for KeyEvent.VK_RIGHT, call the right method on the model;
c) for KeyEvent.VK_UP key, call the up method on the model;
d) for KeyEvent.VK_DOWN key, call the down method on the model.
4) If the model's maxTile field becomes equal to WINNING_TILE, set the isGameWon flag to true.
5) Finally, call the repaint method on the view.

P.S. To get the key code, use the KeyEvent class's getKeyCode method.



