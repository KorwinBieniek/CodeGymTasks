taskKey="com.codegym.task.task35.task3513.big09"\n\n2048 (part 9)


You're doing really well! It's so good that I decided to help you a little and have already implemented the View class.
It's quite simple. It inherits the JPanel class, overrides the paint method, and displays
the current state of the model obtained using the controller.

But you have to finish implementing the Controller class.

To start, we're going to need a constructor. It will have one Model parameter, initialize the model
field, and also save a new View object in the view field, passing the current controller (this) to the
constructor.

Next, we need a resetGame method that can return the game board to its initial state.
You need to reset the score, set the isGameWon and isGameLost flags on the view to false, and call the
resetGameTiles method on the model. Note: set the field values directly, without using setters.

Add a private constant int WINNING_TILE = 2048. It will determine the tile weight that, when achieved,
constitutes a win.

And now, the most important thing! To be able to process user input, you need to
override the keyPressed method with a single KeyEvent parameter.
The logic of the method should be as follows:
1) If the ESC key was pressed, call the resetGame method.
2) If the model's canMove method returns false, set the isGameLost flag to true.
3) If both the isGameLost and isGameWon flags are false, process the movement events:
a) for KeyEvent.VK_LEFT, call the left method on the model;
b) for KeyEvent.VK_RIGHT, call the right method on the model;
c) for KeyEvent.VK_UP key, call the up method on the model;
d) for KeyEvent.VK_DOWN key, call the down method on the model.
4) If the model's maxTile field becomes equal to WINNING_TILE, set the isGameWon flag to true.
5) Finally, call the repaint method on the view.

P.S. To get the key code, use the KeyEvent class's getKeyCode method.


Requirements:
1.	A private static constant int WINNING_TILE = 2048 must be created in the Controller class.
2.	The Controller class constructor with one Model parameter must be implemented in accordance with the task conditions.
3.	The resetGame method should return the game to its initial state, as described in the task conditions.
4.	The keyPressed method should call the resetGame method if the ESC key is pressed.
5.	The keyPressed method must set the isGameLost flag to true if no move is possible.
6.	The keyPressed method should call the correct methods for moving the game board if a corresponding key is pressed and both the isGameLost and isGameWon flags are false.
7.	The keyPressed method should set the isGameWon flag to true if the model.maxTile and WINNING_TILE fields become equal after the movement.
8.	The keyPressed method should call the repaint method on the object saved in the view field.


2048 (part 8)


The model is almost ready! Let's add a couple more simple methods and start implementing the controller.

Our model lacks a way to get the game board in order to pass it to the view for rendering,
as well as a method that can determine whether a move is possible in the current position.


For its part, the controller will be mainly used to handle user input from the keyboard,
so we'll make it a child of the KeyAdapter class.

We're going to need private model and view fields of the appropriate types, as well as getGameTiles and getScore methods
that return the corresponding properties of the model.

Breaking it into simple steps:
1. Add a getter for the gameTiles field to the Model class.
2. Add to the Model class a canMove method that returns true if a move that changes
the state of the game board is possible given the current position. Otherwise, it should return false.
3. Make the Controller class a child of the KeyAdapter class.
4. Add to the Controller class a getGameTiles method that calls the same method on the model.
5. Add to the Controller class a getScore method that returns the current score (model.score).



2048 (part 7)


We've implemented movement to the left. Now we need to implement the right, up, and down methods. I'm sure you can handle it
without my help, so I'll give you just one hint.

What happens if you rotate a two-dimensional array clockwise by 90 degrees, shift it to the left, and then
rotate three times?



2048 (part 6)


So, you've implemented tile consolidation and merging. The combination of these operations gives us the ability to move to the left.
Great! But we also need to add a new tile if the game board was changed by the movement.

Let's do the following:
1. Change the consolidateTiles method so that it returns true if it makes changes to the input array,
otherwise false.
2. Do the same for the mergeTiles method.
3. Implement the left method, which will call the consolidateTiles and mergeTiles methods for each row of the
gameTiles array and, if necessary, use the addTile method to add a tile.
4. The left method should not be private, since it will be called from the Controller class and elsewhere.



2048 (part 5)


The main actions that we need to enable are movements left, right, up and down.
If you've already played 2048, then you know that when you move in a direction, tiles
with values move to empty tiles, and tiles with the same value combine.

As a basic scenario, let's consider movement to the left and think about what happens when we want to do
this action.

For each row or column, two things actually happen:
a) Consolidate the tiles so that all the empty tiles are on the right, i.e.
the row {4, 2, 0, 4} becomes {4, 2, 4, 0}
b) Merge tiles with the same value, i.e. the row {4, 4, 2, 0} becomes {8, 2, 0, 0}.
Note that the row {4, 4, 4, 4} will become {8, 8, 0, 0}, and {4, 4, 4, 0} becomes {8, 4, 0 , 0}.

Create consolidateTiles(Tile[] tiles) and mergeTiles(Tile[] tiles) methods that implement steps
a) and b) respectively. We will use them only inside the Model class, so give them the narrowest
possible access.

Also, add int score and int maxTile fields, which should store the current score and the highest tile weight
on the game board. The score increases after each merger. For example, if the current score is 20 and
the row {4, 4, 4, 0} is merged, then the score should increase by 8. The access level for these fields should be wider than private.
The easiest thing to do is to update these fields in the mergeTiles method, for example:
1) If the tile merger condition is satisfied, check whether the new value is greater than the maximum value and,
if necessary, change the value of the maxTile field.
2) Increase the value of the score field by the amount of the tile weight generated by the merger.

P.S. When we implement the movement methods, tiles will always be consolidated before they are merged, so
you can assume that the mergeTiles method will always be passed an array of tiles that does not have empty tiles in the middle.



2048 (part 4)


The game 2048 begins on a board where two tiles already have initial values. But our board is still empty :(.
Before you rush to write code, let's think about how this could be implemented.

I suggest creating a private addTile method that will look at which tiles are empty. And if there are empty tiles, it will change the weight of one of them,
chosen at random, to 2 or 4 (there should be 1 four for every 9 twos). To get a random item from the list,
you can use the following expression: (list size * random number between zero and one).
You can also get empty tiles using a separate private getEmptyTiles method that returns a list
of the empty tiles in the gameTiles array.

After implementing the functionality for adding new tiles, add two addTile method calls to the constructor
to satisfy the task's starting condition.

P.S. Perhaps it would be worth it to move all the code from the constructor to a resetGameTiles method so that
starting a new game doesn't require creating a new model. You could instead simply return to the initial state
by calling this method. The access level should be wider than private.
P.P.S. To calculate the weight of a new tile, use the expression (Math.random () < 0.9 ? 2 : 4).



