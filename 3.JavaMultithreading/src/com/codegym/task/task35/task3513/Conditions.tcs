taskKey="com.codegym.task.task35.task3513.big15"\n\n2048 (part 15)


To compare the fitness of different moves, we need to implement support for the Comparable interface
in the MoveFitness class.

In the compareTo method, compare the numbers of empty tiles (numberOfEmptyTiles) first. If the number of empty
tiles is equal, then compare the scores (score). If the scores are also equal, then we will consider the moves to be equally
fit and return zero.

Next we move to the Model class and implement two methods:
1) boolean hasBoardChanged - It returns true if the tile weights in the gameTiles array
differs from the tile weights in the topmost array of the previousStates stack. Note that we
must not remove the top element from the stack. Use the peek method.
2) MoveFitness getMoveFitness(Move move) - It has one Move parameter, and returns
a MoveFitness object that describes the fitness of the passed move. Here are some tips:
a) don't forget to call the rollback method to restore the correct game state;
b) if the move doesn't change the state of the game board, make the number of empty tiles and the score of the MoveFitness object
-1 and 0, respectively;
c) you can make a move by calling the move method on the object passed as an argument.


Requirements:
1.	The MoveFitness class must support the Comparable interface.
2.	The compareTo method should correctly compare two MoveFitness objects.
3.	The hasBoardChanged method must be implemented in accordance with the task conditions.
4.	The getMoveFitness method should return the fitness of the move passed as an argument.
5.	If the move passed to the getMoveFitness method does not change the playing field, the number of empty cells in the returned object must be equal to -1.
6.	The getMoveFitness method must not change the tile weights in the gameTiles array or the score.


2048 (part 14)


A random move is certainly not bad, but it's much cooler to implement the ability to make smart moves. We won't get bogged down in neural networks.
To start, we'll focus on a fairly simple idea.

Obviously, a good move should eventually bring us closer to victory, namely, a tile with 2048.
I propose the following option for comparing the fitness of different moves:
1) Move 1 is better than Move 2 if it results in more empty tiles on the board
than Move 2.
2) Move 1 is better than Move 2 if it results in a higher total score than
Move 2.

To make this comparison, we can make a move, evaluate its fitness, and then
undo the move to return the game to its initial state. Applying this sequence of actions
to all four movement options, we can identify the best move and execute it.

Conceptually, we need two classes: one to describe the move, and another to describe its fitness.

Create a Move interface with one void move method. Annotate the interface with the @FunctionalInterface annotation type, which
indicates that there will be only one abstract method in this interface.

Create a MoveFitness class that describes the fitness of the move. It will need to have private int
numberOfEmptyTiles and scores fields, as well as a private Move move field.
The MoveFitness class needs a constructor with three parameters (int numberOfEmptyTiles, int score, Move move)
for initializing the fields, and a getter for the move field.



2048 (part 13)


Your progress is impressive! To change things up, I suggest giving the game the ability to
choose the next move on its own.

Let's start with the simple. In the Model class, implement a randomMove that randomly calls one of the movement
methods. You can implement this by calculating n = ((int) (Math.random () * 100)) % 4.
The resulting number will be a pseudorandom integer in the range [0..3]. You can associate each number in this range
with one of the methods left, right, up, or down.

Don't forget to add a call to the randomMove method in the Controller class's keyPressed method in response to a press of the R key
(code - KeyEvent.VK_R).

P.S. I'll leave you entirely responsible for checking the correctness of the randomMove method.
I'll only check for the presence of a call to the Math.random() method.



2048 (part 12)


Well, shall we try our algorithm in action? We still need to add logic to save the game state at the beginning of each
movement method, as well as another key processing case for undoing the last move.

When saving the current state to the stack, be sure that the current state is always saved
and only once. If you listened to my advice and used rotations and a call to the left method
to implement the right, up, and down method, you can use the following approach:
1) At the very beginning of the right, up, and down methods, call the saveState method with gameTiles as the argument.
2) In the left method, check whether the saveState method has already been called. We have the isSaveNeeded flag
for this. If it is true, we save the state. After performing
a left shift, we set the isSaveNeeded flag to true.

Also, make the Controller class's keyPressed method call the rollback method when the Z key (code KeyEvent.VK_Z) is pressed.



2048 (part 11)


Good work! At this stage, we already have a full-featured application, but there’s no limit to perfection.
Let's do some more work.

If you've managed to play 2048 a little, you've noticed that sometimes you really want to be able to undo
your last move.

Let's create two stacks in the Model class: one to store the previous states of the game board, and the other
to store previous scores. Let's call them previousStates and previousScores. You can initialize them immediately when they are declared
or in the constructor. Use the standard stack implementation (java.util.Stack).

Add a boolean isSaveNeeded field and set it to true. We'll need it in the future.

We have places to store state. Now we'll implement two methods to work with them.
1. The private saveState method with one Tile[][] parameter will use the push method to save the current
game board and score in stacks and set the isSaveNeeded flag to false.
2. The public rollback method will use the pop method to set the current game state to the last state
added to the stacks.

Note that when you save the gameTiles array, you need to create a new array and populate it
with new Tile objects before saving it to the stack.

In the rollback method, perform a simple assignment (gameTiles = previousStates.pop()) and do the same for the score.
There's no need for a deep copy.

Before restoring the game state using the rollback method, don't forget to check whether the stacks are empty
to avoid throwing an EmptyStackException.



2048 (part 10)


It's time to start implementing the main method in the Main class—to finally be able to launch the game and relax!

We only need the main method to run the application. We've already implemented all the guts.
To do this, in the main method, we'll create a model and controller, as well as a JFrame object. I'll call it game,
but you can choose any name you want.

We will need to call some methods on our game (JFrame object) in order for everything to be displayed correctly
on the screen:

game.setTitle("2048");
game.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
game.setSize(450, 500);
game.setResizable(false);

game.add(controller.getView());

game.setLocationRelativeTo(null);
game.setVisible(true);

Pay attention to the add method to which we pass the view from the controller. We don't yet have a getter for the view field
in the Controller class. Don't forget to add it.

P.S. Finishing this task will result in a working version of the game 2048. If something doesn't work,
or doesn't work as expected, be sure to figure it out and fix it before moving on to the subsequent tasks.



