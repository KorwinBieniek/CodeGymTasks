taskKey="com.codegym.task.task31.task3110.big15"\n\nArchiver (part 15)


It's time to try to extract something. To do this, add a public void extractAll(Path
outputFolder) throws Exception method to the ZipFileManager class. The Path outputFolder parameter is the path to which we will
extract our archive. You already have extensive experience working with zip entries and streams, so I'll
only give you some hints on how to implement this method. You'll have to think carefully about how
to do the following:
1.	Check whether the zip file exists
2.	If the outputFolder directory does not exist, then it needs to be created, along with all the folders that
contain it.
3.	Inside the archive, some files may be inside folders. In this case, the ZipEntry.getName() method
doesn't exactly return the file name, as might be expected from the method name. Instead, it returns the file's relative path
inside the archive. This relative path should be retained after the extraction process is complete, but
it will become relative to the directory where we have extracted the archive
4.	Implement the ZipExtractCommand class's execute() method by analogy with our implementation of
ZipCreateCommand. Make a similar try-catch block, and simply change the displayed messages
so that the user knows we are currently extracting an archive, and that we need the archive's
full name and the directory to which we will extract the archive. Don't forget to call the
ZipFileManager class's extractAll method, and not createZip like we did in the ZipCreateCommand
5.	Run the program and enjoy the extracted results

Note:
Use Files.newInputStream(Path path) and Files.newOutputStream(Path path) to get read and write streams.


Requirements:
1.	You need to create a public void extractAll(Path outputFolder) throws Exception method in the ZipFileManager class.
2.	The extractAll(Path outputFolder) method must throw a NoSuchZipFileException if the archive file does not exist.
3.	The extractAll(Path outputFolder) method must create the outputFolder directory if it doesn&#39;t exist.
4.	The extractAll(Path outputFolder) method must extract all of the files from the archive into the outputFolder directory.
5.	The ZipExtractCommand class&#39;s execute() method must get the ZipFileManager object and extract the files to the directory specified by the user.


Archiver (part 14)


Everything is ready to implement the ZipContentCommand class's execute() method:
1.	Display "Viewing contents of the archive."
2.	Create a ZipFileManager object using the getZipFileManager() method
3.	Display "Archive contents:"
4.	Get a list of the archive's files using the getFileList() method
5.	Display the properties of each file. The previously implemented
FileProperties.toString() method will come in handy
6.	Display "Archive contents viewed."
7.	Run the program and verify that the "View the contents of an archive" command works



Archiver (part 13)


Let's continue to move toward getting the contents of an archive. Let's write a getFileList() method inside the
ZipFileManager class. It will return a list of the files in the archive, or rather a list of the properties of these files (
we already implemented the FileProperties class). Let's begin:
1.	Add a List<FileProperties> getFileList() throws Exception method to the ZipFileManager class.
2.	Inside that method, check whether zipFile is a regular file using
a suitable method from the Files class. If it is not a file, throw a NoSuchZipFileException.
3.	Create a list of FileProperties objects. We'll add the file properties to it.
4.	Create a ZipInputStream for the file represented by the zipFile variable. As we've done before, wrap the creation of this object
in a try-with-resources.
5.	Go through all of the ZipEntries in the ZipInputStream
6.	For each ZipEntry, read its contents (otherwise, we won't have information about its
size). You can't find the size of a file in an archive without reading it. This is super easy to do
using the copyData method and a temporary ByteArrayOutputStream buffer.
7.	Get the name, size, compressed size, and compression method of the zip entry. Take a look at what else you can
learn about the entry.
8.	Create a FileProperties object using the obtained file data.
9.	Add the object created in step 8 to the list from step 3.
10.	Return the gathered information to the method that called the getFileList method.



Archiver (part 12)


Today we'll prepare to implement ZipContentCommand. It will be responsible for getting
an archive's contents. The archive's contents are compressed files and folders, but we're interested
in knowing not only the names of the archive's objects, but also their size before and after compression,  their compression ratio, and
the compression method used.
We'll create a FileProperties class that will be responsible for the properties of each file in the archive. Out set of properties
consists of the following: file name, file size before and after compression, and compression method.
1.	Create the FileProperties class
2.	Add the following private instance variables to it:
2.1. String name - The file name
2.2. long size - The size in bytes
2.3. long compressedSize - The size after compression in bytes
2.4. int compressionMethod - The compression method
3.	Add getters for them
4.	Add a FileProperties(String name, long size, long compressedSize, int
compressionMethod) constructor
5.	Add a long getCompressionRatio() method that will calculate the compression ratio as:
100 - ((compressedSize * 100) / size)
6.	Override the String toString() method so that it returns a String formatted as follows:
"name size KB (compressedSize KB) compression: compressionRatio%" if the file size is greater than 0. Otherwise, it should
only return the file name. For example, a directory might have a size of 0. Don't forget
to convert bytes to kilobytes. Note that the number of bytes in a kilobyte isn't the same as the number of grams in a kilogram. Nor is it the same as the number of
chips in that bag... Hmm, maybe it's time for me to grab a snackâ€¦



Archiver (part 11)


Finally, we'll try to provide a decent implementation for the ZipCreateCommand class's execute() method that
we added previously. To do this, we need to:
1.	Display "Creating an archive." at the beginning of the method. Don't forget that we are using
the ConsoleHelper class to work with the console.
2.	Create a new ZipFileManager object. Since we will also need to create this object
in other commands, move the creation logic to a separate ZipFileManager getZipFileManager() throws
Exception method in the ZipCommand class. This method should:
2.1. Ask the user to enter the full path to the archive
2.2. Read the path into a String variable
2.3. Use the entered String to create a Path variable
2.4. Create a ZipFileManager object, passing the obtained path to the constructor
2.5. Return the created object
3.	Ask the user to enter the full path to the file or directory to be zipped
4.	Create a Path using the entered String
5.	Call the ZipFileManager object's createZip() method, passing the path from step 4 to it
6.	Display "Archive created."
7.	Wrap the contents of the ZipCreateCommand's execute() method in a try-catch block and catch
PathNotFoundException exceptions. If one occurs, display the message: "You
didn't correctly enter a file name or directory."
8.	Run the program and verify that the "Zip files into an archive" command works



Archiver (part 10)


It's time to refactor the ZipFileManager class. The createZip method has code that we're also
going to need in the methods that will add files to or remove them from an archive, extract files, etc. We'll
implement those methods later, but we can move the common code to separate
methods now.
Additionally, the createZip method can only create an archive from a single file, but we would like to be able to
zip an entire folder. We won't create a separate method for this, since you can pass
both a directory and a regular file to the createZip(Path source) method.
Today's tasks:
1.	Implement a private void addNewZipEntry(ZipOutputStream zipOutputStream, Path filePath,
Path fileName) throws Exception method in the ZipFileManager class. It must:
1.1. Create an InputStream for the file named fileName located in
the filePath directory
1.2. Create a new ZipEntry, using fileName as the name
after converting it to a String
1.3. Copy the data from the InputStream (from step 1.1) to the zipOutputStream parameter
1.4. Close the zip entry
1.5. Close the InputStream using try-with-resources
2.	Replace part of the createZip method's code with a call to the addNewZipEntry method. Pass source.getParent()
as the filePath parameter, and source.getFileName() as the filename.
3.	Implement a private void copyData(InputStream in, OutputStream out) throws Exception method. It
must read data from "in" and write to "out", until it reads through everything.
4.	Replace part of the addNewZipEntry method's code with a call to the copyData method.
5.	Let's return to createZip:
5.1. At the beginning of the method, check to see if the directory (zipFile.getParent()) where we
will create zipFile exists; if not, then create it.
5.2. If source is a regular file (use Files.isRegularFile to check), then simply call
addNewZipEntry.
5.3. If source is a directory (use Files.isDirectory to check), then:
5.3.1.	Create a FileManager object, passing
source to the constructor
5.3.2.	Get a list of files from the file manager, and save them to the
fileNames variable
5.3.3.	Call addNewZipEntry(zipOutputStream,
source, fileName) for each element of fileNames.
5.4. If source isn't a folder or a file, throw a
PathNotFoundException.



