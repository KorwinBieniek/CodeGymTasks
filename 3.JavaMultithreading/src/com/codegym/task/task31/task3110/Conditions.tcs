taskKey="com.codegym.task.task31.task3110.big10"\n\nArchiver (part 10)


It's time to refactor the ZipFileManager class. The createZip method has code that we're also
going to need in the methods that will add files to or remove them from an archive, extract files, etc. We'll
implement those methods later, but we can move the common code to separate
methods now.
Additionally, the createZip method can only create an archive from a single file, but we would like to be able to
zip an entire folder. We won't create a separate method for this, since you can pass
both a directory and a regular file to the createZip(Path source) method.
Today's tasks:
1.	Implement a private void addNewZipEntry(ZipOutputStream zipOutputStream, Path filePath,
Path fileName) throws Exception method in the ZipFileManager class. It must:
1.1. Create an InputStream for the file named fileName located in
the filePath directory
1.2. Create a new ZipEntry, using fileName as the name
after converting it to a String
1.3. Copy the data from the InputStream (from step 1.1) to the zipOutputStream parameter
1.4. Close the zip entry
1.5. Close the InputStream using try-with-resources
2.	Replace part of the createZip method's code with a call to the addNewZipEntry method. Pass source.getParent()
as the filePath parameter, and source.getFileName() as the filename.
3.	Implement a private void copyData(InputStream in, OutputStream out) throws Exception method. It
must read data from "in" and write to "out", until it reads through everything.
4.	Replace part of the addNewZipEntry method's code with a call to the copyData method.
5.	Let's return to createZip:
5.1. At the beginning of the method, check to see if the directory (zipFile.getParent()) where we
will create zipFile exists; if not, then create it.
5.2. If source is a regular file (use Files.isRegularFile to check), then simply call
addNewZipEntry.
5.3. If source is a directory (use Files.isDirectory to check), then:
5.3.1.	Create a FileManager object, passing
source to the constructor
5.3.2.	Get a list of files from the file manager, and save them to the
fileNames variable
5.3.3.	Call addNewZipEntry(zipOutputStream,
source, fileName) for each element of fileNames.
5.4. If source isn't a folder or a file, throw a
PathNotFoundException.


Requirements:
1.	Add a private void addNewZipEntry(ZipOutputStream zipOutputStream, Path filePath, Path fileName) throws Exception method to the ZipFileManager class.
2.	The addNewZipEntry method must be implemented according to the task conditions.
3.	Replace part of the createZip method&#39;s code with a call to the addNewZipEntry method.
4.	Add a private void copyData(InputStream in, OutputStream out) throws Exception method to the ZipFileManager class.
5.	The copyData method must read data from &quot;in&quot; and write to &quot;out&quot; until it reads all of the bytes.
6.	Replace part of the addNewZipEntry method&#39;s code with a call to the new copyData method.
7.	The createZip method in the ZipFileManager class must be completed according to the task conditions.


Archiver (part 9)


Now let's take care of another part of our archiver that is no less important. Frequently, users want to
create an archive from not just one file, but from an entire folder. In this case, zipping amounts to
successively adding a ZipEntry for each file to the archive.
We need to write a FileManager class to get a list of all of the files in some folder. It must
have a constructor that has a Path rootPath parameter that indicates the root (the folder containing the files
we are interested in), and a List<Path> getFileList() method that should return a list
of relative paths for all of the files in rootPath (including files in subfolders).
The directory we will search can only be set once in the constructor. So, we can generate
the list of files (relative paths) right in the constructor and save it in
the class's List<Path> fileList variable.
We just have to decide how to gather up all of the files, even those that might be inside a folder, inside a folder,
inside a folder, inside the folder we're looking at. Whoa, we almost entered a recursive loop. But maybe recursion can
help us! Let's make a collectFileList(Path path) method that adds all the files inside the path parameter to the class's fileList variable,
and calls itself recursively on
subfolders.
1.	Create a FileManager class with a FileManager(Path rootPath) throws IOException constructor
2.	Declare and initialize the following private instance variables:
2.1. Path rootPath - The root path of the directory whose files we are interested in
2.2. List<Path> fileList - The  list of relative paths of files inside rootPath
3.	Create a getter for fileList
4.	Implement a void collectFileList(Path path) throws IOException method that must:
4.1. Check to see if the path parameter is a regular file (use the
Files.isRegularFile method), then get its path relative to rootPath
and add it to fileList.
4.2. If the path parameter is a directory (determine this using the
Files.isDirectory method), then go through all of the directory's contents and call
collectFileList(Path path), passing in the discovered elements.
You can go through the all of the directory's contents by first getting a DirectoryStream using the
Files class's newDirectoryStream method. Don't forget to close the DirectoryStream.
5.	Call the collectFileList(rootPath) method inside the FileManager constructor.
6.	Apply everything you've learned about encapsulation to this class.
In completing this task, you wrote an algorithm that traverses a file tree. But Java has a special
FileVisitor interface for this. I highly recommend you learn how to use it.



Archiver (part 8)


To find out which command the user currently wants to execute, let's add an Operation
askOperation() method to the Archiver class. This method should display a list of available commands and
ask the user to choose one of them. For convenience, we will ask the user to enter the command's number, which is its
ordinal number in the Operation enum. You can get an enum field's ordinal number
using the ordinal() method.
Now everything is ready to rewrite the main method using our latest scientific advancements, specifically
the CommandExecutor class and the askOperation() method.
1.	Add a public static Operation askOperation() throws IOException method to the Archiver class.
It must:
1.1. Use the ConsoleHelper class's methods
1.2. Ask the user for the number of the desired operation. Hint:
To display the number of the "Create archive" operation, use: Operation.CREATE.ordinal()
1.3. Return the selected operation.
Example output of the askOperation() method:
Select an operation:
0 - Zip files into an archive
1 - Add a file to an archive
2 - Remove a file from an archive
3 - Extract an archive
4 - View the contents of an archive
5 - Exit
2.	Rewrite the main() method:
2.1. Declare a local Operation variable
2.2. In a loop, use the askOperation() method to ask for a new value for the variable in step 2.1, and
use CommandExecutor.execute() to perform the operation.
2.3. Allow the user to exit the loop by selecting the Operation.EXIT operation
2.4. Wrap the askOperation() and execute(operation) calls in a try-catch block. If a
NoSuchZipFileException occurs, use ConsoleHelper to display "You didn't select an archive or
you selected an invalid file." If any other exceptions occur,
display "An error occurred. Please check the entered data."
2.5. Be sure that the program continues running (continues to a new iteration of the loop)
after handling exceptions.
3.	Run the program and verify that the "exit" command works.



Archiver (part 7)


We've done a lot and can take a quick break.
Let's create an exception package and add two classes to it: PathNotFoundException and NoSuchZipFileException.
We'll throw a PathNotFoundException exception if we can't find the path needed
to extract the archive, or the path to the file you want to zip, or any other path. A NoSuchZipFileException
will be thrown if there is an attempt to do something with an archive that doesn't
exist.
1.	Create the exception package
2.	Add to it a PathNotFoundException class that inherits Exception
3.	Add a NoSuchZipFileException class that also inherits Exception



Archiver (part 6)


Suppose the user uses the Operation operation variable to let us know what he or she wants
to do. Then we need to check the variable, create a corresponding
command object, and call its execute() method. To avoid creating the required command object
every time, we need to store it somewhere. Let's create a CommandExecutor class for this. We'll give it
just one public static execute(Operation operation) method, which will find
the required command and call its execute method.
1.	Create a CommandExecutor class. It should be located at the root of the task. Don't add it to the command package.
2.	Prevent direct calls to the class's constructor
3.	Add a private static constant Map<Operation, Command> allKnownCommandsMap to the class to
store the commands.
4.	Initialize the allKnownCommandsMap field so that each field of the Operation enum
corresponds to the correct command.
5.	Implement the public static execute(Operation operation) throws Exception method, which
must select the required command from allKnownCommandsMap and call its execute method.
Whether or not you realized it, you just implemented the command pattern!



Archiver (part 5)


Let's divide the commands into two types: those that work directly with the archive, and helpers
(for example, EXIT). All the commands of the first type will have shared functionality. It's convenient to pull this functionality
into a common base class. Let's call this class ZipCommand. Like all command classes, it must
implement the Command interface. All commands that work with an archive must
inherit the ZipCommand class. We won't create any ZipCommand objects, so
let's make it abstract.
1.	Create an abstract ZipCommand class that implements the Command interface
2.	Create a class for each command. All of the listed commands must
inherit ZipCommand and have an empty execute() method. We'll write
the implementation for each command separately as we implement our archiver.
2.1. ZipCreateCommand is the command for creating an archive (zipping files into an archive)
2.2. ZipContentCommand is the command for viewing an archive's contents
2.3. ZipExtractCommand is the command for extracting an archive
2.4. ZipAddCommand is the command for adding a file to an archive
2.5. ZipRemoveCommand is the command for removing a file from an archive



