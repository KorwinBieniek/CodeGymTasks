taskKey="com.codegym.task.task31.task3110.big07"\n\nArchiver (part 7)


We've done a lot and can take a quick break.
Let's create an exception package and add two classes to it: PathNotFoundException and NoSuchZipFileException.
We'll throw a PathNotFoundException exception if we can't find the path needed
to extract the archive, or the path to the file you want to zip, or any other path. A NoSuchZipFileException
will be thrown if there is an attempt to do something with an archive that doesn't
exist.
1.	Create the exception package
2.	Add to it a PathNotFoundException class that inherits Exception
3.	Add a NoSuchZipFileException class that also inherits Exception


Requirements:
1.	A PathNotFoundException class that inherits Exception must be created in the exception package.
2.	A NoSuchZipFileException class that inherits Exception must be created in the exception package.


Archiver (part 6)


Suppose the user uses the Operation operation variable to let us know what he or she wants
to do. Then we need to check the variable, create a corresponding
command object, and call its execute() method. To avoid creating the required command object
every time, we need to store it somewhere. Let's create a CommandExecutor class for this. We'll give it
just one public static execute(Operation operation) method, which will find
the required command and call its execute method.
1.	Create a CommandExecutor class. It should be located at the root of the task. Don't add it to the command package.
2.	Prevent direct calls to the class's constructor
3.	Add a private static constant Map<Operation, Command> allKnownCommandsMap to the class to
store the commands.
4.	Initialize the allKnownCommandsMap field so that each field of the Operation enum
corresponds to the correct command.
5.	Implement the public static execute(Operation operation) throws Exception method, which
must select the required command from allKnownCommandsMap and call its execute method.
Whether or not you realized it, you just implemented the command pattern!



Archiver (part 5)


Let's divide the commands into two types: those that work directly with the archive, and helpers
(for example, EXIT). All the commands of the first type will have shared functionality. It's convenient to pull this functionality
into a common base class. Let's call this class ZipCommand. Like all command classes, it must
implement the Command interface. All commands that work with an archive must
inherit the ZipCommand class. We won't create any ZipCommand objects, so
let's make it abstract.
1.	Create an abstract ZipCommand class that implements the Command interface
2.	Create a class for each command. All of the listed commands must
inherit ZipCommand and have an empty execute() method. We'll write
the implementation for each command separately as we implement our archiver.
2.1. ZipCreateCommand is the command for creating an archive (zipping files into an archive)
2.2. ZipContentCommand is the command for viewing an archive's contents
2.3. ZipExtractCommand is the command for extracting an archive
2.4. ZipAddCommand is the command for adding a file to an archive
2.5. ZipRemoveCommand is the command for removing a file from an archive



Archiver (part 4)


Each command implies the execution of some action. Create a Command interface with
an execute() method.  We'll create a separate class
for each command. All of the command classes must implement (inherit) the Command interface.
Since there will be a lot of commands, we'll create a separate command package for them. We'll store all of the command-related
interfaces and implementations in it.
The simplest command is EXIT, so let's start with that.
1.	Create the command package
2.	Declare the Command interface in it
3.	Add a void execute() throws Exception method to the Command interface
4.	Declare an ExitCommand class that implements the Command interface
5.	Implement the execute() method in the ExitCommand class. It should use the ConsoleHelper class to display
"Bye!"
6.	At the very end of the Archiver class's main method, add code that creates an
ExitCommand object and calls its execute() method
7.	Check that it all works
Note that all the project files must be encoded in UTF-8. You can set the encoding in IntelliJ IDEA
under Settings -> Editor -> File Encodings. Be sure that all three fields responsible for encoding
are set to UTF-8.



Archiver (part 3)


As you can see, zipping isn't that bad. But our archiver is somehow
too primitive. A real archiver should be able to do much more: extract an archive,
add a new file to an existing archive, remove a file from an archive, and view the contents
of an archive. Now let's improve our archiver. To do that, we have to write a few new
classes. First, let's create an Operation enum, which will contain all the commands that
our archiver supports.
It would also be convenient to use ConsoleHelper to work with the console so that everything console-related
is gathered into the same class. Going forward, unless indicated otherwise, all input and output
should happen through ConsoleHelper.
1.	Declare the Operation enum, and add the following commands to it:
1.1. CREATE - Create an archive
1.2. ADD - Add a file to an archive
1.3. REMOVE - Remove a file from an archive
1.4. EXTRACT - Extract an archive's contents
1.5. CONTENT - View an archive's contents
1.6. EXIT - Exit the program
2.	Create a ConsoleHelper class and implement the following static public methods in it:
2.1. void writeMessage(String message) - Display a message on the console
2.2. String readString() - Read a String from the console
2.3. int readInt() - Read a number from the console
Methods that read from the console can throw an IOException if an input error occurs. Account for
this in their declarations.



Archiver (part 2)


Now let's implement the createZip(Path source) method, which will zip the file
specified by the source argument.
Java has a special ZipOutputStream class in the java.util.zip package. It compresses (zips) the
data passed to it. To keep multiple files from blending together when they are compressed into one archive,
we create a special entity called a ZipEntry for each of them. In other words, we
first put a ZipEntry in the ZipOutputStream, and then we write the file's contents. When the file is written, it is automatically
compressed, and when it is read, it is automatically decompressed. A ZipEntry doesn't have to be a file; it can also be a
folder.
To zip a file (create a new archive and add the file to it):
1.	Create a new ZipOutputStream using the zipFile variable and the
Files class's newOutputStream method.
2.	Create a new ZipEntry. Pass a String containing the new entry's name to the ZipEntry constructor.
You need to get the name from the full path source. Get only the file name and convert it to a String.
3.	Add the created zip entry to the zip stream.
4.	Copy the data from the file we are zipping to the zip stream. To do this:
4.1. Create an InputStream for the source file using the Files class's newInputStream method.
4.2. Make a loop that will read data from the InputStream (created in 4.1) as long as it has data and write
that data to the ZipOutputStream (created in step 1)
4.3. Close the InputStream using a try-with-resources
5.	Close the zip stream's zip entry
6.	Close the zip stream using a try-with-resources
7.	Run the program and verify that a file can be zipped



