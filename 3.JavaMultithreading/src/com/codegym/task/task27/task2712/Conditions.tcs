taskKey="com.codegym.task.task27.task2712.big21"\n\nRestaurant (part 21)


We continue to fix the bug.

Now all the orders arrive in the queue, but they don't reach the cooks.
We'll make OrderManager find any available cook and give it an order. To implement this logic,
we need a deamon thread. It will check for orders in the queue, and then grab available cooks and give them orders.

We're going to need a method that determines whether a cook is busy.
1. In the Cook class, create a boolean busy field with a getter.
2. At the beginning of the startCookingOrder method, set busy to true; and at the end of the method, set it to false.
3. In the startCookingOrder method, simulate the delay resulting from preparing a dish: sleep for 10 times the order's required preparation time.
In other words, if an order takes 30 minutes to prepare, then the delay will be 30 * 10 milliseconds.
4. To get a list of all the cooks, in the StatisticsManager class, add a getter for the field that is populated in the register(Cook cook) method.

5. In the OrderManager constructor, create and run a daemon thread. Here's the logic of the run method:
check the queue every 10 milliseconds. If the queue has orders, then look for available cooks and pass
them the orders (startCookingOrder method). If there are no available cooks or there are no orders in the queue, then keep waiting.


Requirements:
1.	A boolean busy field and corresponding getter must be created in the Cook class.
2.	The daemon thread described in the task conditions must be created and started in the OrderManager class constructor.
3.	In the startCookingOrder method, the Thread.sleep() method must be called with an argument equal to ten times the order&#39;s required preparation time.


Restaurant (part 20)


Fix a bug: a tablet sends its orders to all known chefs.
Expected behavior: a tablet sends its orders to a queue, and an available cook takes orders from the queue.

There are two ways to implement this functionality:
1) Each tablet stores a reference to the queue and pushes new orders to it.
2) A tablet pushes its orders to the Observer, which stores a reference to the queue. The Observer puts the order into the queue.

We'll take the second option.
1. In the root of the project, create an OrderManager class that will be an Observer for the tablets.
2. In the OrderManager class, create a LinkedBlockingQueue<Order> orderQueue field. Add to it all orders passed to the update method.
3. The Cook class is now NOT an Observer.
4. In the Cook class, create a void startCookingOrder(Order order) method. Move the update method's logic into this method.
5. Remove the update method from the Cook class.
6. In the main method, arrange an Observer-Observable relationship in view of the changes above.



Restaurant (part 19)


We need to rework the main method.

First, let's make the parameters of our RandomOrderGeneratorTask constructors consistent.
Please make your method signature the same as mine:
RandomOrderGeneratorTask(List<Tablet> tablets, int interval)

In the main method:
1. Remove the creation of the hardcoded tablet and calls to the createOrder() method.
2. Create a second cook.
3. Register the cooks using the StatisticsManager class.
4. Arrange Observer/Observable classes for the second cook and all the tablets.
5. Create a list of 5 tablet objects. Initialize it in a loop.
6. Create and run a thread based on a RandomOrderGeneratorTask object.
7. After a second, interrupt it and look at the console output.

Oops, two cooks are preparing the same order! 8-O

We got this output because the Observable is informing all of its Observers, i.e. a tablet sends its order to all known cooks.
This isn't the behavior we want, so we will correct it in the next task.

P.S. Don't forget to stop the thread!



Restaurant (part 18)


Currently, we have one tablet and 1 cook.
Let's create several tablets that will randomly generate orders, and we'll make two cooks.

1. In the Restaurant class, create a constant PRIVATE static int ORDER_CREATION_INTERVAL = 100.

2. In a separate file, create a (Runnable) RandomOrderGeneratorTask class. This task should:
2.1. Maintain a list of all the tablets
2.2. Use Math.random to select a random tablet.
2.3. RandomOrderGeneratorTask should have only one method.
2.4. Generate a random order every ORDER_CREATION_INTERVAL milliseconds for the tablet in item 2.2 (don't display a stack trace)
Now an order is created in the Tablet class's createOrder method.
In the Tablet class, create a void createTestOrder() method with similar functionality
that will randomly generate an order with random dishes without communicating with a real person.
Pass all the necessary data to in the constructor.
Hint:
a) create a TestOrder class (descendant of Order) in the parent's package.
b) in the Order class, create a protected initDishes() method that initializes the dishes. Call this method in the constructor
c) in the Order class, make the dishes field protected
d) override initDishes in the TestOrder class. Initialize the order with a random set of dishes.
e) instead of creating an Order object in the Tablet class's createTestOrder() method, create a TestOrder object.
All of the createTestOrder method's other functionality remains the same

3. Refactor the createTestOrder() and createOrder() methods: in one of the methods, select the code that is repeated in both methods,
press Ctrl+Alt+M, enter any name for the method, and click OK. IDEA will offer to replace the code in the second method. Confirm the action.



Restaurant (part 17)


Let's implement the third and fourth statistics items: the lists of active and inactive videos
It will be easier to do this with access to the video repository (AdvertisementStorage class).
1. In the ad package, create a StatisticsAdvertisementManager that will provide information from AdvertisementStorage in the required form.
Make it a singleton.

2. In the StatisticsAdvertisementManager class, create and initialize a AdvertisementStorage field.

3. In the StatisticsAdvertisementManager, create one (or two) methods (you decide) that fetch all the necessary data from the
AdvertisementStorage: the list of active commercials and the list of inactive commercials.
An active video is one that has at least one remaining impression.
An inactive video is one with 0 remaining impressions.

4. Implement the logic of the ManagerTablet class's printActiveVideoSet and printArchivedVideoSet methods.
Use the method(s) created in the previous item.
Sort alphabetically by the name of the video


Example output for printActiveVideoSet:
First Video - 100
Second Video - 10
Third Video - 2
Fourth Video - 4

In this example, printArchivedVideoSet would display the following after 50 impressions:
Second Video
Third Video
Fourth Video



Restaurant (part 16)


Let's implement the first statistics item: advertising revenues, grouped by day.

1. In the VideosSelectedEventDataRow class, create a getter for the amount field.
In the OrderReadyEventDataRow class, create a getter for the cookName field.

2. In StatisticsManager, create a method (come up with its name on your own) that will get all repository data
related to displaying advertising, and will calculate the total revenues for each day.
Additionally, add a get helper method to the repository class to access the data.

3. Let's start with the logic of the printAdRevenue method in the ManagerTablet class.
Using the method from the previous item, display the dates and amounts in decreasing order.
For each date with displayed ads in the event repository, the revenue per impression for that date should be displayed.
At the end, display "Total" and the total amount.
Example:
14-Jul-2013 - 2.50
13-Jul-2013 - 1.02
12-Jul-2013 - 543.98
Total - 547.50

4. Let's implement the second statistics item: cook utilization (time spent working), grouped by day.

In StatisticsManager, create a method (come up with its name on your own) that will get all repository data
related to a cook's work, and will calculate the total time spent working for each cook separately.

5. Implement the logic of the ManagerTablet class's printCookUtilization method.
Using the method from the previous item to display dates, names of cooks, and hours worked (round up), in decreasing order.
For each date in the event repository with a record about work performed by a cook, the time worked on that date in minutes should be displayed.
If a cook did not work on a day, then DO NOT display empty data for him or her (see 13-Jul-2013)
Sort the cooks by name
Example:
14-Jul-2013
Puck - 60 min
Ramsay - 35 min

13-Jul-2013
Puck - 129 min

12-Jul-2013
Puck - 6 min
Ramsay - 5 min

6. Please note that when displaying the date, the name of the month must be in English (when formatting, you can pass Locale.ENGLISH as an argument).



