taskKey="com.codegym.task.task27.task2712.big07"\n\nRestaurant (part 7)


When choosing which class to start from, try to find one that is used by others, and which does not use anything.
In our case, this is the repository of advertising videos (AdvertisementStorage).
We decided that it would be the only one in the restaurant and made it a singleton.
Let's describe it.

1. The videos need to be stored somewhere. Let's make it a list.
Create a videos field and initialize it with an empty list.
Think about whether the videos field should be able to change its value?

2. To make it possible to work with the videos, create the following public methods:
2.1. list() - returns a list of all available videos.
2.2. add(Advertisement advertisement) - adds a new video to the videos list.

3. In the class constructor, let's add some data to the videos list. This is what I have:
Object someContent = new Object();
new Advertisement(someContent, "First Video", 5000, 100, 3 * 60) // 3 min
new Advertisement(someContent, "Second Video", 100, 10, 15 * 60) // 15 min
new Advertisement(someContent, "Third Video", 400, 2, 10 * 60)   // 10 min

4. In the AdvertisementManager class, we'll create a final field that references an instance of AdvertisementStorage and call it storage.
Don't forget to initialize this field!


Requirements:
1.	A storage field that references an instance of the AdvertisementStorage class must be created in the AdvertisementManager class.
2.	In the AdvertisementStorage class, the videos list must be declared with the final modifier.
3.	In the AdvertisementStorage class, the list method must return the videos list and must be public.
4.	In the AdvertisementStorage class, the add method must have one Advertisement parameter and add the passed object to the videos list.
5.	In the AdvertisementStorage class constructor, several Advertisement objects must be added to the videos list.


Restaurant (part 6)


An order is created, prepared by the cook, and then carried out to the guest. We also calculate the time required to fill the order.
We'll consider the first part of the task complete.
Let's move on to the second: while the order is being prepared, ads should be shown on the tablet.
Let's define what we mean by ads.

For us, an ad is a video of a certain duration. We also know that someone has paid for a number of impressions.
We'll assume that we know the number of paid impressions, the total cost of all impressions, and the ad itself.

1. Create an ad package for ad-related functionality.

2. In the ad package, create an Advertisement class that has the following fields:
Object content - the video
String name - the name or title
long amountPaid - the amount paid for ads in cents. Use a long to avoid rounding problems
int impressionsRemaining - the number of impressions that have been paid for but not shown
int duration - the duration in seconds
Set the access modifiers on your own.

3. In the Advertisement class, create a constructor with parameters ordered according to the sequence of fields listed above

4. We'll create another two classes in the same package:
AdvertisementStorage - a repository of commercials.
AdvertisementManager - each tablet will have its own manager object
that will select and sequence the optimal set of videos for each order.
It will also interact with the player and display the videos.

5. Since there is only one AdvertisementStorage for the entire restaurant, we'll make it a singleton.



Restaurant (part 5)


The cook currently prepares dishes instantaneously. In reality, cooking takes some time.
We need to calculate the time required to prepare the entire order, so we can then select commercials to fill the time.

1. Suppose we know the cooking time for each dish in minutes. We'll hardcode it in the Dish class.
1.1. Change the creation of the enum fields: Fish(25), Steak(30), Soup(15), Juice(5), Water(3);
1.2. Create a private int duration field with a getter.
To create a getter, press Alt+Insert and select Getter. Next, select the field name and click OK (Enter).

2. Add the ability to calculate the time required to prepare the whole order.
Where should you add it???
2.1. If you add it to the Cook class, then the cook will be able to calculate how long it will take to prepare the order.
For other classes to get this information, they will need access the Cook object.
2.2. If you add it to the Order class, then access to the order will always let you find out how long the order will take.
2.3. Choose the right place from either item 2.1 or item 2.2, and add a public int getTotalCookingTime() method,
which will calculate the total time required to prepare all the dishes in the order.
2.4. Let's add this information to what our cook outputs to the console. Now let's display a message like this:
Start cooking - Your order: [Soup, Juice, Water] from Tablet{number=5}, cooking time 23 min

Let's make it pretty:
3. Start the application and immediately enter 'exit'. The output isn't very beautiful.
Make it so that if there are no dishes in the order, then it doesn't get sent to the cook. Find this relevant place and implement the logic.
In the Order class, create a public boolean isEmpty() helper method that determines whether there are any dishes in the order.



Restaurant (part 4)


What do we have? The cook has prepared the dishes. It's time to take them away, but the waiter is unaware.
We need to notify the waiter that it's time to pick up the order from the kitchen.
This situation is similar to the previous task, so we'll use the Observer pattern again.

1. Create a Waiter class in the kitchen package. It will carry the orders back to the table. The waiter won't have a name.

2. Cook prepares orders, and Waiter processes them. Properly assign Observer and Observable to Waiter and Cook.

3. The void update method will display a message about the order and who prepared it:
order + " was prepared by " + cook

4. In the class that inherits Observable, we'll do the following before sending an order:
4.1. Set the flag using setChanged()
4.2. Send the order to the observer using notifyObservers(order);

5. Let's write the main method.
For the Observable object, add our own Observer object. See item 2 and the description of the pattern in Wikipedia
We give the cook a name. The name doesn't affect the tests. In my version, the cook's name is Amigo. :)

Let's check the console output. Example of my output:
Your order: [Water] from Tablet{number=5}
Start cooking - Your order: [Water] from Tablet{number=5}
Your order: [Water] from Tablet{number=5} was prepared by Amigo



Restaurant (part 3)


Now we can create orders. Let's make it so they are automatically sent to the cook.
There are many different ways to implement this functionality.
Read about the Observer pattern at http://en.wikipedia.org/wiki/Observer_pattern
It's already implemented in Java, and we're going to use it.

1. Create a Cook class in the kitchen package. It's going to handle the cooking. The constructor will take the cook's name, which will be output by the toString method.

2. Tablet creates orders, and Cook prepares them. Properly assign Observer and Observable to Tablet and Cook.

3. The void update(Observable observable, Object arg) method, which must be implemented, has two parameters.
- observable is the object that sent us the value
- arg is the value itselfâ€”in our case, an Order object
At this stage, we'll only simulate preparing the orders by displaying "Start cooking - " + order

3. Let's write the main method.
For the Observable object, add our own Observer object. See item 2 and the description of the pattern in Wikipedia
We give the cook a name. The name doesn't affect the tests. In my version, the cook's name is Amigo. :)

Let's check the console output. Example of my output:
Your order: [Soup] from Tablet{number=5}
Start cooking - Your order: [Soup] from Tablet{number=5}

4. Don't forget to do the following immediately after creating the order and displaying it on the console (find this place in the code):
4.1. Set the flag using setChanged()
4.2. Send the order to the observer using notifyObservers(order);

5. We'll also make a small change. Make it so that the createOrder method returns the current order, or null if the order couldn't be created.



Restaurant (part 2)


1. We work with the console a lot. It's time to create a single point of interaction.
Create a ConsoleHelper class with a single BufferedReader, through which we will work with the console.
Remember, this class does not store any data or state, so all its methods will be static.
Create three methods in it:
- writeMessage(String message) - for displaying message on the console
- String readString() - for reading strings from the console
- List<Dish> getAllDishesForOrder() - asks the customer to select a dish and adds it to the list.
Display a list of all the dishes and ask the customer to enter a string (the name of a dish).
The customer enters 'exit' to indicate the order is complete.
If the entered dish is not on the menu, display a message stating that there is no such dish and continue taking the order.
Rethrow IO exceptions. It isn't clear what to do with them at this level.

2. Refactor the code so that we work with the console only through the ConsoleHelper class.

3. Let's return to the Order class: it has a reference to the tablet, as well as a list of chosen dishes.
Initialize the dishes list in the constructor by calling the getAllDishesForOrder method from the ConsoleHelper.

4. Rewrite the toString method in the Order class. Let it return an empty string if there are no dishes in the order. Otherwise,
the output should be similar to the example, in the order in which the dishes were added. Use ConsoleHelper.
Also, change the Tablet class's toString method (inside the Tablet class, press Alt+Insert -> toString()).
Example:
Your order: [Juice, Fish] from Tablet{number=5}

5. We have everything tied to the console. But, if there are exceptions, our application will die.
To learn the cause, we'll add to the Tablet class a static java.util.logging.Logger logger field, initialized with the class name (Logger.getLogger(Tablet.class.getName())).

6. We handle IO exceptions in the Tablet class's createOrder method.
Let's write "The console is unavailable." The log level is SEVERE, which is the most serious level (the application cannot continue).
Also, a new order must be created in the Tablet class's createOrder method.

7. We need to start testing our application.
In the main method, create a tablet and create four orders.



