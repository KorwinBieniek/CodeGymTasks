taskKey="com.codegym.task.task27.task2712.big13"\n\nRestaurant (part 13)


Let's return to the StatisticsManager class's record method. It should record events in a repository.
Let's create the repository :)
The repository has a 1-to-1 relationship with the manager, i.e. there is one manager and one repository per application.
Only the StatisticsManager can access the repository. Therefore...
From the above, it follows that the repository must be a private inner class.
Let's call it StatisticsStorage.

1. Inside the StatisticsManager class, create a private inner StatisticsStorage class.

2. To allow the manager to access the repository, you need to create a StatisticsStorage statisticsStorage field in the StatisticsManager class.
Initialize it with an instance of the class.

3. StatisticsStorage will store data internally in a Map storage field.
The StatisticsStorage and Map must have a has-a relationship
The maps type arguments are <EventType, List<EventDataRow>>

4. In the StatisticsStorage constructor, initialize the repository with default data:
for example, use a loop to add a new ArrayList <EventDataRow>() for each EventType.


Requirements:
1.	A private StatisticsStorage class must be created in the StatisticsManager class.
2.	The statisticsStorage field must be created and initialized in the StatisticsManager class.
3.	A Map&lt;EventType, List&lt;EventDataRow&gt;&gt; storage field must be created in the StatisticsStorage class.
4.	The storage field must be filled with some values.


Restaurant (part 12)


We have several events:
*The cook prepared an order
*The set of videos for an order has been chosen
*There are no videos that can be shown while an order is prepared

These are constants, so an enum is suitable for representing them.

1. In the event package, create the following: enum EventType {ORDER_READY, VIDEOS_SELECTED, NO_VIDEOS_AVAILABLE}

2. In the event package, create three classes corresponding to the enum fields. They will (should) represent events.
We will record them in the repository.
Here are the class names and constructor parameters:
2.1. OrderReadyEventDataRow(String tabletName, String cookName, int cookingTimeSeconds, List<Dish> dishesInOrder)
where tabletName is the name of the tablet
cookName is the name of the cook
cookingTimeSeconds is the time required to prepare the order in seconds
dishesInOrder is the list of dishes to prepare
2.2. NoVideosAvailableEventDataRow(int totalDuration)
totalDuration is the time required to prepare the order in seconds
2.3. VideosSelectedEventDataRow(List<Advertisement> optimalVideoSet, long amount, int totalDuration)
optimalVideoSet is the list of videos chosen for playback
amount is the amount of money in cents
totalDuration is the total duration of the chosen commercials
3. In the classes created in item 2, add a Date currentDate field, which you will initialize in the constructor with the current date.



Restaurant (part 11)


We've implemented the first two of the three features. You will recall that the first was automated order preparation,
the second was commercial selection, and the third is statistics for the manager. And that's our next step.

We need to implement the following functionality:
1) calculate the statistics
2) display the statistics to the manager

Let's try to determine the sequence of actions. To display data, you must first get it from somewhere.

There are two approaches:
The FIRST approach is applied when it is difficult to obtain real data, or when someone else does the work to get the data:
1. hardcode the data in the application
2. display the hardcoded statistics
3. get the real data/statistics (integrate with someone else's code)

SECOND:
1. get the real data/statistics
2. display the statistics

Because we're implementing this functionality ourselves, and the statistics aren't complicated, we'll adopt the second approach.
Let's start by getting the real data and real statistics.

Here's the idea:
There's an event repository.
When an event occurs, we'll record it in the repository.
Upon a request from the manager, we'll filter the events in the repository, and then calculate and display the necessary data.

First, we need several classes.
1. Create a statistics package, where we'll create a StatisticsManager class. We'll use it to record events in the repository.
2. We should have one repository with one entry point. Therefore, we'll make StatisticsManager a singleton.
3. Inside the statistics package, create a nested event package to store event-related classes.
4. Create an EventDataRow interface in the event package. At the moment, it's a marker interface,
since it doesn't have methods and we use it to determine whether the passed object is an event.
5. In StatisticsManager, create a public void record(EventDataRow data) method that records the event in the repository.
We'll return to the implementation later.



Restaurant (part 10)


Recursion is used when the algorithm for solving the problem is the same as the algorithm for solving part of the problem.
That's just what we have. We need to do a full search of all options and choose the best of them.

Let me remind you of the pattern used to write recursive code:
a) condition for terminating the recursion
b) condition for continuing the recursion (recursive call with a set of parameters from the previous step).
You can always find detailed information online about how to write recursion.

Our current task is to provide a recursive implementation of item 2.2 of the previous task:
(choose a list of available videos that maximizes revenues)
The recursive method must chose the set of commercials that will be displayed to the customer.

This set must meet the following requirements:
1) the amount of money received from impressions should be the maximum of all possible options
2) the total commercial playback time must NOT exceed the cooking time for the current order;
3) a video is shown no more than once for any given order;
4) if several different sets of videos will produce the same amount of money from impressions, then:
4.1) choose the option that maximizes the total time;
4.2) if the total time is the same for multiple such options, then select the option with the smallest number of videos;
5) the number of remaining impressions of any commercial in the set must be positive.

And don't forget to implement item 2.4 of the previous task (display all the relevant videos).

The revalidate() method must be called for each video shown.



Restaurant (part 9)


We need an exception that will help us handle the situation where we are unable to choose commercials.

1. Create an unchecked NoVideoAvailableException in the ad package.

2. Let's take a closer look at the void processVideos() method in AdvertisementManager.
2.1. Remove the code that displays "calling the processVideos method"
The method should:
2.2. Choose a list of available videos that maximizes revenues. (Don't do this yet—we'll do it later).
2.3. If there are no advertising videos that can be shown to the customer, then throw a NoVideoAvailableException,
which you will need to catch (think about where the best place to do this would be), and log the following phrase with logging level Level.INFO
"No video is available for the following order: " + order
2.4. Display all the chosen commercials in order of decreasing cost per impression
in cents. The secondary sort order is by increasing the cost per impression per second of commercial in thousandths of a cent
Use the Collections.sort method
(Again, don't do this yet—we'll do it later).
Example for [Water]:
Displaying First Video... 50, 277
where "First Video" is the name of the commercial
where 50 is the cost per impression in cents
where 277 is the cost per impression per second of commercial in thousandths of a cent (equal to 0.277 cents)
Use the methods of the Advertisement class.
2.5. In the Advertisement class, create a void revalidate() method. This method should:
2.5.1. Throw an UnsupportedOperationException if the number of impressions is not positive.
2.5.2. Decrement the number of remaining impressions.



Restaurant (part 8)


It's time to describe the functionality of the AdvertisementManager class.
But first we're going to need some methods in the Advertisement class.

1. Create a long amountPerImpression field in the Advertisement class.
It should equal the cost of one ad impression in cents (amountPaid / impressionsRemaining).
Assign a value to the field in the constructor.

2. In the Advertisement class, create getters for the name, duration, and amountPerImpression fields.

3. Determine what data the AdvertisementManager object needs, i.e. the time required for the cook to prepare an order.
Because we're storing the duration of the videos in seconds, we'll also take the cooking time in seconds.
In the AdvertisementManager class, create a constructor that has one parameter: int timeSeconds.
Create a corresponding field and save this value in it.

4. AdvertisementManager performs just one action—it processes ad videos.
Therefore, create the only public method: void processVideos(). Its functionality will be described in the next task.
But for now, display "calling the processVideos method"

5. To test this functionality, you need to add a call to the processVideos method to the AdvertisementManager.
Obviously, this method should be called during creation of an order, or more precisely—in parallel with the creation of an order.
The order is prepared while the video is watched.
Add a call to the processVideos() method in the right place.

P.S. Don't forget that an order's preparation time is recorded in minutes, but the time of an ad impression in measured in seconds!



