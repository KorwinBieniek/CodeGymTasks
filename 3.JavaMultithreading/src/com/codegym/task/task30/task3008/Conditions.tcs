taskKey="com.codegym.task.task30.task3008.big07"\n\nChat (part 7)


Because the server can work with multiple clients simultaneously, we're going to need
a method to send a message to everyone all at once.

Add the following to the Server class:
1) A static Map<String, Connection> connectionMap field, where the key is the client name,
and the value is the connection with the client.
2) Initialization of the field from step 7.1 using the appropriate Map from the java.util.concurrent library,
since this field will be accessed from different threads and we need to ensure thread safety.
3) A static void sendBroadcastMessage(Message message) method, which should send the message argument
to all connections in connectionMap. If an IOException occurs while the message is being sent,
you need to catch it and inform the user that the message couldn't be sent.


Requirements:
1.	The Server class must have a static Map connectionMap field.
2.	The connectionMap field must be initialized using a thread-safe implementation of the Map interface from the java.util.concurrent package.
3.	The Server class must correctly implement the static sendBroadcastMessage(Message message) method, which sends a message to all connections in connectionMap.


Chat (part 6)


Let's move on to the most important part: writing the Server class.
The server must support multiple simultaneous connections with different clients.
This can be done using the following algorithm:
- The server creates a server socket connection.
- In a loop, the server waits for some client to connect to the socket.
- It creates a new Handler thread on which messages will be exchanged with the client.
- It waits for another connection.

Add the following:
1) To the Server class, a nested private static Handler class that inherits Thread.
2) To the Handler class, a Socket socket field.
3) To the Handler class, a constructor that has a Socket parameter and uses it to initialize the appropriate field.
4) The Server's main method should:
a) Request a server port using ConsoleHelper.
b) Create a java.net.ServerSocket object using the port from the previous step.
c) Display a message indicating that the server is running.
d) In an infinite loop, listen for and accept incoming socket connections with the newly created server socket.
e) Create and start a new Handler thread, passing the socket from the previous step to the constructor.
e) Once the Handler thread is created, proceed to the next iteration of the loop.
g) Be sure that the server socket is closed if there is an exception.
h) If an Exception occurs, catch it and display an error message.



Chat (part 5)


The client and server will communicate through a socket connection.
One side will write data to the socket, while the other will read. They interact by exchanging Messages.
The Connection class will wrap the java.net.Socket class,
which needs to be able to serialize and deserialize Message objects to/from the socket.
The methods of this class should be callable from different threads.

Add the following to the Connection class:

1) Final fields:
a) Socket socket
b) ObjectOutputStream out
c) ObjectInputStream in

2) A constructor that has a Socket parameter and initializes the object's fields.
To initialize the in and out fields, use the socket's corresponding threads.
The constructor may throw an IOException. You need to create an ObjectOutputStream object before creating an ObjectInputStream object.
Otherwise, threads trying to establish a connection through the Connection class may block each other.
You can read more about this in the documentation for the ObjectInputStream class.

3) A void send(Message message) throws IOException method.
It should write (serialize) the message to the ObjectOutputStream.
This method will be called from multiple threads.
Be sure that only one thread can write to the ObjectOutputStream object at a time.
Other threads must wait their turn. However, other methods of the Connection class should not be blocked.

4) A Message receive() throws IOException, ClassNotFoundException method. It should read (deserialize) data from the ObjectInputStream.
Make it so a read operation can't be performed simultaneously by multiple threads,
but be sure not to block calls to other methods of the Connection class.

5) A SocketAddress getRemoteSocketAddress() method, which returns the remote address of the socket connection.

6) A void close() throws IOException method, which should close all the resources used by the object.

The Connection class should support the Closeable interface.



Chat (part 4)


A Message is data that one party sends and the other receives.
Each message must have a MessageType and some additional data,
for example, a text message must contain text.
Since the messages will be created in one program and read in another,
it will be convenient to use serialization to convert objects to sequences of bits and back again.

Add the following to the Message class:
1) support for the Serializable interface.
2) a final MessageType field that will contain the message type.
3) a final String field that will contain the message data.
4) getters for these fields.
5) a constructor that accepts only a MessageType. It should initialize
the type field using the passed parameter, and leave the data field as null.
6) a constructor that has MessageType type and String data parameters. It should also initialize all of the object's fields.



Chat (part 3)


Before moving on, we need to work out the protocol for communication between the client and server.

Let's outline the main aspects of the protocol:
- When a new client wants to connect to the server, the server should request the client name.
- When a client receives a name request from the server, it should send its name to the server.
- When the server receives a client name, it should accept the name or request a new one.
- When a new client is added to the chat, the server should inform the other participants about the new client.
- When a client leaves the chat, the server should inform the other participants.
- When the server receives a text message from a client, it should forward it to all the other chat participants.

For each item in the protocol described above, add corresponding values to the MessageType enum:
1) NAME_REQUEST – A name request.
2) USER_NAME – A username.
3) NAME_ACCEPTED – The name is accepted.
4) TEXT – A text message.
5) USER_ADDED – The user was added.
6) USER_REMOVED – The user was deleted.



Chat (part 2)


First of all, for convenience in working with the console, we'll implement the ConsoleHelper class. In
the future, any work with the console should happen through this class.

Add the following to it:
1) A static BufferedReader field initialized using System.in.
2) A static writeMessage(String message) method that should display
the message string on the console.
3) A static String readString() method that should read a string from
the console. If an exception occurs while reading, display the following message
to the user: "An error occurred while trying to enter text. Try again." And
read the input again. The method should not throw an IOException upward.
Other exceptions should not be handled.
4) A static int readInt() method. It should return the entered number and
use the readString() method. Handle any NumberFormatExceptions inside
the method. If one occurs, then display the following message to the user "An error
while trying to enter a number. Try again." And read in another number.

In this and later tasks, unless specified otherwise, all of a class's fields must
be private and its methods must be public.



