taskKey="com.codegym.task.task30.task3008.big05"\n\nChat (part 5)


The client and server will communicate through a socket connection.
One side will write data to the socket, while the other will read. They interact by exchanging Messages.
The Connection class will wrap the java.net.Socket class,
which needs to be able to serialize and deserialize Message objects to/from the socket.
The methods of this class should be callable from different threads.

Add the following to the Connection class:

1) Final fields:
a) Socket socket
b) ObjectOutputStream out
c) ObjectInputStream in

2) A constructor that has a Socket parameter and initializes the object's fields.
To initialize the in and out fields, use the socket's corresponding threads.
The constructor may throw an IOException. You need to create an ObjectOutputStream object before creating an ObjectInputStream object.
Otherwise, threads trying to establish a connection through the Connection class may block each other.
You can read more about this in the documentation for the ObjectInputStream class.

3) A void send(Message message) throws IOException method.
It should write (serialize) the message to the ObjectOutputStream.
This method will be called from multiple threads.
Be sure that only one thread can write to the ObjectOutputStream object at a time.
Other threads must wait their turn. However, other methods of the Connection class should not be blocked.

4) A Message receive() throws IOException, ClassNotFoundException method. It should read (deserialize) data from the ObjectInputStream.
Make it so a read operation can't be performed simultaneously by multiple threads,
but be sure not to block calls to other methods of the Connection class.

5) A SocketAddress getRemoteSocketAddress() method, which returns the remote address of the socket connection.

6) A void close() throws IOException method, which should close all the resources used by the object.

The Connection class should support the Closeable interface.


Requirements:
1.	The Connection class should support the Closeable interface.
2.	The Connection class must have a private final Socket socket field.
3.	The Connection class must have a private final ObjectOutputStream out field.
4.	The Connection class must have a private final ObjectInputStream in field.
5.	The Connection class must have a constructor with a single Socket parameter that initializes the object&#39;s fields according to the task conditions.
6.	The Connection class must correctly implement the send() method with one Message parameter.
7.	The Connection class must correctly implement the receive() method without parameters.
8.	The Connection class&#39;s getRemoteSocketAddress() method must return the remote address of the socket connection.
9.	The Connection class&#39;s close() method should close the input stream, output stream, and socket connection.


Chat (part 4)


A Message is data that one party sends and the other receives.
Each message must have a MessageType and some additional data,
for example, a text message must contain text.
Since the messages will be created in one program and read in another,
it will be convenient to use serialization to convert objects to sequences of bits and back again.

Add the following to the Message class:
1) support for the Serializable interface.
2) a final MessageType field that will contain the message type.
3) a final String field that will contain the message data.
4) getters for these fields.
5) a constructor that accepts only a MessageType. It should initialize
the type field using the passed parameter, and leave the data field as null.
6) a constructor that has MessageType type and String data parameters. It should also initialize all of the object's fields.



Chat (part 3)


Before moving on, we need to work out the protocol for communication between the client and server.

Let's outline the main aspects of the protocol:
- When a new client wants to connect to the server, the server should request the client name.
- When a client receives a name request from the server, it should send its name to the server.
- When the server receives a client name, it should accept the name or request a new one.
- When a new client is added to the chat, the server should inform the other participants about the new client.
- When a client leaves the chat, the server should inform the other participants.
- When the server receives a text message from a client, it should forward it to all the other chat participants.

For each item in the protocol described above, add corresponding values to the MessageType enum:
1) NAME_REQUEST – A name request.
2) USER_NAME – A username.
3) NAME_ACCEPTED – The name is accepted.
4) TEXT – A text message.
5) USER_ADDED – The user was added.
6) USER_REMOVED – The user was deleted.



Chat (part 2)


First of all, for convenience in working with the console, we'll implement the ConsoleHelper class. In
the future, any work with the console should happen through this class.

Add the following to it:
1) A static BufferedReader field initialized using System.in.
2) A static writeMessage(String message) method that should display
the message string on the console.
3) A static String readString() method that should read a string from
the console. If an exception occurs while reading, display the following message
to the user: "An error occurred while trying to enter text. Try again." And
read the input again. The method should not throw an IOException upward.
Other exceptions should not be handled.
4) A static int readInt() method. It should return the entered number and
use the readString() method. Handle any NumberFormatExceptions inside
the method. If one occurs, then display the following message to the user "An error
while trying to enter a number. Try again." And read in another number.

In this and later tasks, unless specified otherwise, all of a class's fields must
be private and its methods must be public.



Chat (part 1)


Today we're going to write a chat system: A set of programs that you can use
to exchange text messages. The system will consist of one server and
multiple clients, one for each chat participant.

Let's start with the server. We'll need the following classes:
1) Server - The server's main class.
2) MessageType - An enum responsible for the types of messages sent between
a client and the server.
3) Message - The class responsible for the sent messages.
4) Connection - A class representing the connection between a client and the server.
5) ConsoleHelper - A helper class for reading or writing to the console.

Create these classes and add the main method to the Server class.



