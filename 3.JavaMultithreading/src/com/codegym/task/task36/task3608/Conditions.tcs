taskKey="com.codegym.task.task36.task3608.big05"\n\nMVC (part 5)


The service has a method that returns all deleted users. Let's display them.

1. Assign each of these methods to the correct MVC classes:

public void fireShowDeletedUsersEvent() {
...onShowAllDeletedUsers();
}

public void onShowAllDeletedUsers() {
...loadDeletedUsers();
}

public void loadDeletedUsers() {
List<User> users = userService.getAllDeletedUsers();
}

Don't forget that the data received from the server must be stored in the DataModel. And then, update the view.
Add this to the correct methods on your own.

2. In Solution.main, call the new method that you put in the view.

3. Add the method that you put in the Model to the Model interface, and implement it in FakeModel: throw an UnsupportedOperationException.


Requirements:
1.	You need to determine the correct location for the fireShowDeletedUsersEvent() method, and implement it.
2.	You need to determine the correct location for the onShowAllDeletedUsers() method, and implement it.
3.	You must determine the correct location for the loadDeletedUsers() method, and implement it.
4.	In the Solution class&#39;s main method, you need to call the method that you previously implemented in the UsersView class.
5.	The Model interface must declare the method that you previously implemented in the MainModel class.
6.	In the FakeModel class, you need to throw an UnsupportedOperationException in the body of the method that was added to the Model interface.


MVC (part 4)


It's time to replace our fake Model with a real one that receives data from the DataSource.
I've added a service for working with users to the model.service package.
You'll also find a Util utility class in the root of this task.

1. Create a MainModel by analogy with FakeModel.

2. Because the Model accesses services, create and initialize a UserService userService field in MainModel.

3. Implement the loadUsers method:
3.1. Get all users between levels 1 and 100. (Use the getUsersBetweenLevels(1, 100) method.)
3.2. Put all of the users into dataModel.

4. Update Solution.main: replace FakeModel with MainModel.
An advantage of MVC is that it's easy to replace any part of the pattern at any time.



MVC (part 3)


To understand whether you're heading in the right direction, you need to see the data. Therefore,
1. In the view package, create a UsersView class that implements View. It will display the list of users.

2. Create a controller field, and a corresponding setter, in UsersView.

3. Implement the refresh method:
3.1. Display the phrase "All users:".
3.2. Display all of the users in dataModel.
Indent each user with a tab.
3.3. Display the following visual separator at the end
===================================================

4. I'm already interested in seeing what we've got.
Add to UsersView a public void fireShowAllUsersEvent() method that emulates a client event.
Access the controller and call the appropriate method to display all users.

5. The Solution class will emulate a user. Open the Solution class, go to the red method,
and use IDEA's hot keys to create a usersView property (field).
All you need is a setter. If you created a getter, delete it.

6. Run main. Oops, nothing is displayed :(
This is because the server sent the data, and it was updated in the DataModel, but the View doesn't know anything about it.
The View can't update itself. The Controller does that.
Go to the controller and update the View's data.
Remember, the data is stored in the Model.

7. Run main. I now have this output:
All users:
User{name='A', id=1, level=1}
User{name='B', id=2, level=1}
===================================================
Hooray! Let's keep going.



MVC (part 2)


1. Create a controller package, and create a Controller class inside it.
This class will receive requests from the client and notify the Model. The Model, in turn, will update the DataModel.

2. Add a Model model field, along with a setter, to the controller.

3. In the controller, create a public void onShowAllUsers() method that accesses the model and triggers the loading the users.

4. Create a view package. Create a View interface inside it.

5. Add two methods to the View interface: void refresh(DataModel dataModel) and void setController(Controller controller).



MVC (part 1)


Hi! This task will cover the Model-View-Controller (MVC) pattern.
Together we are going to build an MVC architecture. Dive in deep to understand why you need to implement it the way that I show you.
Read the additional literature - https://codegym.cc/groups/posts/303-part-7-introducing-the-mvc-model-view-controller-pattern
You'll probably be asked about this pattern in an interview or will be given a task that will require you to implement it.

Let's begin...
You have two packages: bean, which has only one class called User, and dao,
which contains database emulation code in the mock and UserDao packages. UserDao is a DAO layer (i.e. Database Access Object layer).
It contains various methods for storing and retrieving objects from a database.
A real application wouldn't have the line "private DataSource dataSource = DataSource.getInstance()".
I've implemented DataSource as a singleton. In reality, you'd have something more like this:
@Autowired
private DataSource dataSource;
This framework you'll use in real applications will create the database object itself and initialize the dataSource field.

Remember, services work with the DAO layer. No other classes touch the DAO. The business logic is described in services.
Services retrieve data from the database using the DAO, process it, and hand it out to whoever requested the data.
However, not all data is stored in a database. For example, a signed-in user will be stored in a special Model object.
An object that contains data required to display information to the client is called the Model.
Additionally, this Model object contains references to all of the required services.
If there is a lot of data to display, then it is broken out into separate objects.

Let's write an application that will display a list of users and do something with them, for example, update their data and delete them.

1. Create a model package, and create a DataModel class inside it.
DataModel is the entity that will store the data we need to display to the client.
Create a List users field, and a corresponding getter and setter. This will be the list of users to display.

2. We should be able to use any model to get all of the data we need to display. So,
in the model package, create a Model interface that has a DataModel getDataModel() method.

3. Create a FakeModel class that implements Model in the model package. We're going to need this in the initial stage.
Give it a DataModel dataModel field, and initialize it with the object.

4. Create a void loadUsers() method in the Model interface.
Implement it in FakeModel: use arbitrary data to initialize the list of users for dataModel. The data won't affect testing.
I have the following data:
User{name='A', id=1, level=1}
User{name='B', id=2, level=1}
I think you'll remember that all interface methods are public, so there's no need to indicate a modifier.
Programmers often use fake data in early development. They implement code to get real data in the final stages.
The hardcoded fake data replaces real objects.



