taskKey="com.codegym.task.task36.task3608.big06"\n\nMVC (part 6)


The functionality for displaying deleted users exists, but we don't have any deleted users. Let's fix that.
Let's make a new view that will be responsible for editing a specific user.
UsersView displays a list of users.
EditUserView will display data about editing a specific user.
For this, we first need the selected user.
As with any data, we'll put it in DataModel.

1. In DataModel, create a User activeUser field, along with a corresponding getter and setter (Alt+Insert -> Getter and Setter).

2. Create EditUserView by analogy with UsersView.
Here's the logic for the refresh method:
2.1. Display "User to be edited:".
2.2. On a new line, display a tab and then the active user.
2.3. On a new line, display the following separator: "===================================================".

3. Create a EditUserView editUserView field and corresponding setter in the controller.

When our data is displayed, it's not entirely clear whether we are displaying the list of users or the list of deleted users.
Let's make the View display this information. All of the data to be displayed is stored in the Model. Therefore,
4. In DataModel, create a boolean displayDeletedUserList field, along with a corresponding getter and setter.

5. Change the UsersView class's refresh method so that it displays "All users:" or "All deleted users:"
depending on the type of users in the list. Add the displayDeletedUserList change to the required methods of the model.


Requirements:
1.	A private User activeUser field, and a corresponding getter and setter, must be created in the DataModel class.
2.	The EditUserView class must be created by analogy with the UsersView class: it must support the View interface and have a private Controller controller field and corresponding setter.
3.	The EditUserView class&#39;s refresh method must be implemented according to the task conditions.
4.	A private EditUserView editUserView field and corresponding setter must be created in the Controller class.
5.	A private boolean displayDeletedUserList field and corresponding getter and setter must be created in the DataModel class.
6.	The UsersView class&#39;s refresh method must be modified according to the task conditions.
7.	You need to add a call to the setDisplayDeletedUserList(boolean) method using the correct flag in some of the MainModel class&#39;s methods.


MVC (part 5)


The service has a method that returns all deleted users. Let's display them.

1. Assign each of these methods to the correct MVC classes:

public void fireShowDeletedUsersEvent() {
...onShowAllDeletedUsers();
}

public void onShowAllDeletedUsers() {
...loadDeletedUsers();
}

public void loadDeletedUsers() {
List<User> users = userService.getAllDeletedUsers();
}

Don't forget that the data received from the server must be stored in the DataModel. And then, update the view.
Add this to the correct methods on your own.

2. In Solution.main, call the new method that you put in the view.

3. Add the method that you put in the Model to the Model interface, and implement it in FakeModel: throw an UnsupportedOperationException.



MVC (part 4)


It's time to replace our fake Model with a real one that receives data from the DataSource.
I've added a service for working with users to the model.service package.
You'll also find a Util utility class in the root of this task.

1. Create a MainModel by analogy with FakeModel.

2. Because the Model accesses services, create and initialize a UserService userService field in MainModel.

3. Implement the loadUsers method:
3.1. Get all users between levels 1 and 100. (Use the getUsersBetweenLevels(1, 100) method.)
3.2. Put all of the users into dataModel.

4. Update Solution.main: replace FakeModel with MainModel.
An advantage of MVC is that it's easy to replace any part of the pattern at any time.



MVC (part 3)


To understand whether you're heading in the right direction, you need to see the data. Therefore,
1. In the view package, create a UsersView class that implements View. It will display the list of users.

2. Create a controller field, and a corresponding setter, in UsersView.

3. Implement the refresh method:
3.1. Display the phrase "All users:".
3.2. Display all of the users in dataModel.
Indent each user with a tab.
3.3. Display the following visual separator at the end
===================================================

4. I'm already interested in seeing what we've got.
Add to UsersView a public void fireShowAllUsersEvent() method that emulates a client event.
Access the controller and call the appropriate method to display all users.

5. The Solution class will emulate a user. Open the Solution class, go to the red method,
and use IDEA's hot keys to create a usersView property (field).
All you need is a setter. If you created a getter, delete it.

6. Run main. Oops, nothing is displayed :(
This is because the server sent the data, and it was updated in the DataModel, but the View doesn't know anything about it.
The View can't update itself. The Controller does that.
Go to the controller and update the View's data.
Remember, the data is stored in the Model.

7. Run main. I now have this output:
All users:
User{name='A', id=1, level=1}
User{name='B', id=2, level=1}
===================================================
Hooray! Let's keep going.



MVC (part 2)


1. Create a controller package, and create a Controller class inside it.
This class will receive requests from the client and notify the Model. The Model, in turn, will update the DataModel.

2. Add a Model model field, along with a setter, to the controller.

3. In the controller, create a public void onShowAllUsers() method that accesses the model and triggers the loading the users.

4. Create a view package. Create a View interface inside it.

5. Add two methods to the View interface: void refresh(DataModel dataModel) and void setController(Controller controller).



MVC (part 1)


Hi! This task will cover the Model-View-Controller (MVC) pattern.
Together we are going to build an MVC architecture. Dive in deep to understand why you need to implement it the way that I show you.
Read the additional literature - https://codegym.cc/groups/posts/303-part-7-introducing-the-mvc-model-view-controller-pattern
You'll probably be asked about this pattern in an interview or will be given a task that will require you to implement it.

Let's begin...
You have two packages: bean, which has only one class called User, and dao,
which contains database emulation code in the mock and UserDao packages. UserDao is a DAO layer (i.e. Database Access Object layer).
It contains various methods for storing and retrieving objects from a database.
A real application wouldn't have the line "private DataSource dataSource = DataSource.getInstance()".
I've implemented DataSource as a singleton. In reality, you'd have something more like this:
@Autowired
private DataSource dataSource;
This framework you'll use in real applications will create the database object itself and initialize the dataSource field.

Remember, services work with the DAO layer. No other classes touch the DAO. The business logic is described in services.
Services retrieve data from the database using the DAO, process it, and hand it out to whoever requested the data.
However, not all data is stored in a database. For example, a signed-in user will be stored in a special Model object.
An object that contains data required to display information to the client is called the Model.
Additionally, this Model object contains references to all of the required services.
If there is a lot of data to display, then it is broken out into separate objects.

Let's write an application that will display a list of users and do something with them, for example, update their data and delete them.

1. Create a model package, and create a DataModel class inside it.
DataModel is the entity that will store the data we need to display to the client.
Create a List users field, and a corresponding getter and setter. This will be the list of users to display.

2. We should be able to use any model to get all of the data we need to display. So,
in the model package, create a Model interface that has a DataModel getDataModel() method.

3. Create a FakeModel class that implements Model in the model package. We're going to need this in the initial stage.
Give it a DataModel dataModel field, and initialize it with the object.

4. Create a void loadUsers() method in the Model interface.
Implement it in FakeModel: use arbitrary data to initialize the list of users for dataModel. The data won't affect testing.
I have the following data:
User{name='A', id=1, level=1}
User{name='B', id=2, level=1}
I think you'll remember that all interface methods are public, so there's no need to indicate a modifier.
Programmers often use fake data in early development. They implement code to get real data in the final stages.
The hardcoded fake data replaces real objects.



