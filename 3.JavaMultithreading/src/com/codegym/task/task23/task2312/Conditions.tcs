taskKey="com.codegym.task.task23.task2312.big16"\n\nSnake (part 16)


Nothing is forever... That's why the snake must die if it hits a wall or itself.

There's a very simple check to determine whether a snake intersects itself:
does the sections list contain a "new snake's head"?
This is what the code will look like:
if (sections.contains(head))
The head must not be added to the sections list, otherwise this condition will always be true.
But for this code to work, you need to implement object comparison methods (equals and hashCode) in the SnakeSection class.

Hint:
Use Alt+Insert in IntelliJ IDEA to automatically generate equals and hashCode methods.

Task:
a) implement equals and hashCode methods in the SnakeSection class.
b) implement the checkBorders(SnakeSection head) method: if the snake's head is outside the room, the snake dies (isAlive = false)
c) implement the checkBody(SnakeSection head) method: if the snake's head intersects its body, the snake dies (isAlive = false)



Requirements:
1.	The SnakeSection class must have an equals method.
2.	The SnakeSection class must have a hashCode method.
3.	The checkBorders method in the Snake class must be implemented according to the task conditions.
4.	The checkBody method in the Snake class must be implemented according to the task conditions.


Snake (part 15)


Now we need to finish the snake.

Here's my suggestion regarding the snake's motion:
The snake consists of pieces. Each turn, let's just add one piece at the head,
and delete the last one. This will make the snake appear to slither.

Let's add two move methods: one without parameters, and the other with two int parameters.

In the move method without parameters, you must:
a) stop moving if the snake died (isAlive == false)
b) call move(0, -1) if the direction of movement is SnakeDirection.UP
c) call move(1, 0) if the direction of movement is SnakeDirection.RIGHT
d) call move(0, 1) if the direction of movement is SnakeDirection.DOWN
e) call move(-1, 0) if the direction of movement is SnakeDirection.LEFT

We'll leave the move method with (int, int) parameters empty for now.



Snake (part 14)


Now let's work on the print() method.

Here's what we need:
a) display a rectangle of dots, whose dimensions is width x height.
b) represent the body of the snake with an "x"
c) draw the snake's head with an "X".

Hint:
a) it will be helpful to start by creating an int[][] matrix whose dimensions are height x width
b) then walk through all the objects and "draw them" onto the matrix.
For example, you could use 1 for the body of the snake, 2 for the head of the snake, and 3 for the mouse.



Snake (part 13)


This time I'll invite you to write a special sleep() method that will pause
depending on the length of the snake (the number of elements in sections).
Think of some slick algorithm. Make the delay 500 milliseconds on the first level,
and gradually drop it to 300 by Level 11. And to 200 by Level 15. And then have it stay constant.



Snake (part 12)


We have a snake, so let's have a mouse.

Add the following to the main method:
a) a call the createMouse() method.
b) a call the run() method.
Nothing will happen without it. It has all the main logic.
Not bad, but I'll still make a couple of changes.
For example, how about writing a sleep method?
From the previous tasks, you've already realized that the run method needs a pause.
But as I recall, the snake's speed should grow with its length.
This means that the longer the snake, the faster its speed and the shorter the pause.



Snake (part 11)


Now the logic for controlling the mouse.
Two things happen with the mouse.
First, the snake eats the mouse.
Second, a new mouse appears at a random place in the room.

You must write and implement the createMouse() method in the Room class.
This method should just create a new mouse with random coordinates in the room.
How do you get random coordinates?
You should already know. But just in case, I'll give you a clue:
int x = (int) (Math.random() * width);

We also need an eatMouse() method in the event that someone ends up eating the mouse. :)
For now, this method won't have complex logic. We'll just call the createMouse method.



